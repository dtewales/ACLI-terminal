<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
	<meta name="GENERATOR" content="Microsoft&reg; HTML Help Workshop 4.1">
	<Title>Variables</Title>
</HEAD>
<BODY>
<h1>Variables</h1>
<p>Variables are another major feature of the ACLI terminal and are also only available in interactive mode. There are many ways to use variables. They come in handy when having to deal with lists of port numbers, which would otherwise be painful to have to type in every time. The ACLI terminal is particularly geared towards easily capturing port lists or ranges into variables. Variables also come in handy when tie-ing multiple terminals together via the socket functionality, as it allows the user to perform configuration on one terminal which gets executed across many ACLI sessions, and since usually the port numbers and other IDs are not the same across the different switches, these differences can be stored in appropriate variables which when referred to in the driving terminal will be dereferenced to the appropriate value for each and every ACLI session. Once a value is stored in a variable, the variable can be dereferenced by simply embedding it in CLI commands or eval-ed in Perl code also embedded in CLI commands, and they can be used in ACLI's scripting conditional operators as well.</p>
<p>All ACLI perl variables are pre-pended with the dollar '$' sign (much like Perl's scalar variables). Multiple variable types exist.</p>



<div class="section" id="User variables">
<h2>User variables</h2>
<p>User variables are variables defined by the user in the format <i>$&lt;var-name&gt;</i>. The variable name can be made of one or more alphanumeric characters where word characters are case sensitive. The underscore '_' character is allowed in variable names, but not as the 1st character following the dollar sign, with the exception of the variable <i>$_</i> which is a special variable called the default variable. The minus sign '-' is not allowed in variable names.</p>
<p>A user variable comes into existence the moment a value is assigned to it, either via explicit assignment or via capturing.</p>
</div>



<div class="section" id="Default variable">
<h3>Default variable</h3>
<p>The default variable is named <i>$_</i> but can also be referred to as simply <i>$</i> with no name characters following it. It behaves like any other user variable and its intent is simply to be used as a convenience temporary variable to store values which you do not intend to hold on to for long. It is convenient also in that it is quick to type as it can be called with a single character '$'. However, if using the default variable in ACLI scripting conditional operators (@if, @while, @until, etc..) then it must always be referred to as <i>$_</i>. Unlike other user variables, the default variable, if set, cannot be saved with the '@save' command.</p>
</div>



<div class="section" id="Setting user variables">
<h2>Setting user variables</h2>
<p>A user variable can be set simply by making an assignment to it.</p>
<pre>
	VSP-8284XSQ:1#% $myvar = 1/1
	
	$myvar      = 1/1
	
	VSP-8284XSQ:1#%
</pre>
<p>Any string or number can be assigned to a variable.</p>
<pre>
	VSP-8284XSQ:1#% $ = blah blah
	
	$_          = blah blah
	
	VSP-8284XSQ:1#%
</pre>
<p>The default variable was used in the above example. If assigning text to a variable, leading and trailing spaces are removed. If you wanted to preserve leading or trailing spaces then enclose the string in single or double quotes</p>
<pre>
	VSP-8284XSQ:1#% $text = "   indented blah"
	
	$text       = '   indented blah'
	
	VSP-8284XSQ:1#%
</pre>
<p>To overwrite a variable with a different value, simply assign a new value to the same variable.</p>
<p>To append a new value to an existing variable, there are a couple of ways of doing this:</p>
<pre>
	VSP-8284XSQ:1#% $text = "$text even more blah"
	          vars% $text = "   indented blah even more blah"
	
	$text       = '   indented blah even more blah'
	
	VSP-8284XSQ:1#%
</pre>
<p>In the above example, we are assigning a new string to $text, but part of that string is what $text was already set with. Notice that you need to use double quotes here (as variables are not dereferenced inside single quotes). Or else we do it without quotes, if we don't care about leading/trailing spaces:</p>

<pre>
	VSP-8284XSQ:1#% $text = $text, enough
	          vars% $text =    indented blah even more blah, enough
	
	$text       = indented blah even more blah, enough
	
	VSP-8284XSQ:1#%
</pre>
<p>Or we could have used the '.=' append operator to achieve the same:</p>
<pre>
	VSP-8284XSQ:1#% $text .= really enough
	
	$text       = indented blah even more blah, enough,really enough
	
	VSP-8284XSQ:1#%
</pre>
<p>Note that ACLI always stores all variables as just strings of text. However, if there are commas in there, then the variable will chopped up into a list when passed to the ACLI repeat operator '&' or the ACLI scripting '@for' loop. Use of the '.=' operator automatically includes a comma when appending the new value to existing values (if the variable was already set).</p>
<p>This makes more sense when dealing with port numbers; so if we wanted to add another port to our $myvar variable:</p>
<pre>
	VSP-8284XSQ:1#% $myvar .= 1/5
	
	$myvar      = 1/1,1/5
	
	VSP-8284XSQ:1#%
</pre>
<p>Whereas to delete a variable, simply assign nothing to it:</p>
<pre>
	VSP-8284XSQ:1#% $text=
	VSP-8284XSQ:1#%
	VSP-8284XSQ:1#% @vars show $text
	No variables found matching $text
	
	VSP-8284XSQ:1#%
</pre>

<p>User variables are particularly geared towards numbers and port numbers. These can be entered as lists or port ranges and are automatically converted into comma separated lists, but by default displayed as ranges. This might sound a bit confusing, let's go through some examples.</p>
<pre>
	VSP-8284XSQ:1#% $range = 1-10
	
	$range      = 1-10
	
	VSP-8284XSQ:1#% @vars raw $range
	
	$range      = 1,2,3,4,5,6,7,8,9,10
	
	VSP-8284XSQ:1#% @vars show $range
	
	$range      = 1-10
	
	VSP-8284XSQ:1#%
</pre>
<p>We set $range to 1-10. Visibly the variable is set to what we set it at. The '@vars raw' command displays variables as they are actually stored internally in ACLI, i.e. as a comma separated list. Whereas the '@vars show' command will always display more compact ranges, where possible. When using this variable in a CLI command, what will be used is what is shown when simply recalling the variable (i.e. a range in this case). To force ACLI to dereference the raw value instead you can use the <i>$'</i> notation for the same variable:</p>
<pre>
	VSP-8284XSQ:1#% @print $range
	          vars% @print 1-10
	1-10
	
	VSP-8284XSQ:1#% @print $'range
	          vars% @print 1,2,3,4,5,6,7,8,9,10
	1,2,3,4,5,6,7,8,9,10
	
	VSP-8284XSQ:1#%
</pre>
<p>If we wanted to create VLANs or MLTs 1-10 on VOSS, we know there is no single VOSS command which will do that, so we would have no other choice than to use ACLI's repeat operator to achieve this:</p>
<pre>
	VSP-8284XSQ:1(config)#% mlt %s &'$range
	                  vars% mlt %s &'1-10
	VSP-8284XSQ:1(config)#% mlt 1
	VSP-8284XSQ:1(config)#% mlt 2
	VSP-8284XSQ:1(config)#% mlt 3
	VSP-8284XSQ:1(config)#% mlt 4
	VSP-8284XSQ:1(config)#% mlt 5
	VSP-8284XSQ:1(config)#% mlt 6
	VSP-8284XSQ:1(config)#% mlt 7
	VSP-8284XSQ:1(config)#% mlt 8
	VSP-8284XSQ:1(config)#% mlt 9
	VSP-8284XSQ:1(config)#% mlt 10
	VSP-8284XSQ:1(config)#%
</pre>
<p>Note that the ACLI repeat operator '&' does not automatically expand ranges; we need to add the ' character to force it to expand ranges with "&'". Note that we could have achieved the same result by forcing the variable to dereference its raw value like this: <i>mlt %s &$'range</i>. The same is true with the <i>@for</i> operator.</p>
<p>Or we could use ACLI scripting to do the same (deleting the MLTs in this case..); copy-pasting this ACLI script:</p>
<pre>
	@for $_ &'$range
		no mlt $
	@endfor
</pre>
<p>Gives these commands:</p>
<pre>
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 1
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 2
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 3
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 4
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 5
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 6
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 7
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 8
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 9
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#% @for $_ &$range
	VSP-8284XSQ:1(config)#%  no mlt $
	                  vars%  no mlt 10
	VSP-8284XSQ:1(config)#% @endfor
	VSP-8284XSQ:1(config)#%
</pre>
<p>In the case of port numbers, ranges are expanded according to the knowledge ACLI has of the port layout of the connected device.</p>
<pre>
	VSP-8284XSQ:1#% $portRange = 1/1-10/10
	
	$portRange    = 1/1-1/42,2/1-2/42
	
	VSP-8284XSQ:1#%
	VSP-8284XSQ:1#% @vars raw $portRange
	
	$portRange    = 1/1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10,1/11,1/12,1/13,1/14,1/15,1/16,1/17,1/18,1/19,1/20,1/21,1/22,1/23,1/24,1/25,1/26,1/27,1/28,1/29,1/30,1/31,1/32,1/33,1/34,1/35,1/36,1/37,1/38,1/39,1/40,1/41,1/42,2/1,2/2,2/3,2/4,2/5,2/6,2/7,2/8,2/9,2/10,2/11,2/12,2/13,2/14,2/15,2/16,2/17,2/18,2/19,2/20,2/21,2/22,2/23,2/24,2/25,2/26,2/27,2/28,2/29,2/30,2/31,2/32,2/33,2/34,2/35,2/36,2/37,2/38,2/39,2/40,2/41,2/42
	
	VSP-8284XSQ:1#%
</pre>
<p>In the above example, ACLI was connected to a VSP8200, which has 42 ports per slot and 2 slots in total. Hence the port range assigned to our $portRange was pruned back to match the available ports on the connected device. Again '@vars raw' command shows that the variable is internally storing the port range as a list. Whereas for display purposes and when dereferencing the variable, a more compact port range will be used. ACLI will default to compacting ports into ranges which do not span slots, though this is configurable though using the <i>'terminal portrange'</i> command under ACLI control interface or via the <i>default_port_range_mode</i> key in the <i>acli.ini</i> file.</p>
<p>The way port ranges are rendered in slot/port format also depend on the device type ACLI is connected to. If we define a port range where all ports are on the same slot on a VOSS VSP we will get this:</p>
<pre>
	VSP-8284XSQ:1#% $portRange = 1/1-10
	
	$portRange  = 1/1-1/10
	
	VSP-8284XSQ:1#%
</pre>
<p>If we make the same variable assignment on an ERS stack, we will get a different range format:</p>
<pre>
	ERS4900-STK#% $portRange = 1/1-10
	
	$portRange  = 1/1-10
	
	ERS4900-STK#%
</pre>
<p>Notice that ACLI variable is now compacting the port range as <i>x/1-50</i> and not as <i>x/1-x/50</i> as was the case with VOSS.</p>
<p>The same is true if we make that assignment on an XOS stack:</p>
<pre>
	Slot-1 X460G2-STK.9 #% $portRange = 1:1-10
	
	$portRange  = 1:1-10
	
	Slot-1 X460G2-STK.9 #%
</pre>
<p>ExtremeXOS stacks support the same type of port ranges as ERS, and also use the colon ':' character instead of the more common slash '/' for denoting slot/port numbers.</p>
<p>In general, when assigning to variables, ACLI will take port ranges in any valid input format, but will always display and de-reference the variable using only the range format supported by the connected device.</p>
<p>So, for example, <i>ALL</i> is a valid ERS port range, hence we have:</p>
<pre>
	ERS4900-STK#% $allPorts = all
	
	$allPorts     = 1/1-50,2/1-50,3/1-50
	
	ERS4900-STK#% @vars raw $allPorts
	
	$allPorts     = 1/1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10,1/11,1/12,1/13,1/14,1/15,1/16,1/17,1/18,1/19,1/20,1/21,1/22,1/23,1/24,1/25,1/26,1/27,1/28,1/29,1/30,1/31,1/32,1/33,1/34,1/35,1/36,1/37,1/38,1/39,1/40,1/41,1/42,1/43,1/44,1/45,1/46,1/47,1/48,1/49,1/50,2/1,2/2,2/3,2/4,2/5,2/6,2/7,2/8,2/9,2/10,2/11,2/12,2/13,2/14,2/15,2/16,2/17,2/18,2/19,2/20,2/21,2/22,2/23,2/24,2/25,2/26,2/27,2/28,2/29,2/30,2/31,2/32,2/33,2/34,2/35,2/36,2/37,2/38,2/39,2/40,2/41,2/42,2/43,2/44,2/45,2/46,2/47,2/48,2/49,2/50,3/1,3/2,3/3,3/4,3/5,3/6,3/7,3/8,3/9,3/10,3/11,3/12,3/13,3/14,3/15,3/16,3/17,3/18,3/19,3/20,3/21,3/22,3/23,3/24,3/25,3/26,3/27,3/28,3/29,3/30,3/31,3/32,3/33,3/34,3/35,3/36,3/37,3/38,3/39,3/40,3/41,3/42,3/43,3/44,3/45,3/46,3/47,3/48,3/49,3/50
	
	ERS4900-STK#%
</pre>
<p>Likewise on a VOSS VSP:</p>
<pre>
	VSP-8284XSQ:1#% $allPorts = all
	
	$allPorts     = 1/1-1/42,2/1-2/42
	
	VSP-8284XSQ:1#% @vars raw $allPorts
	
	$allPorts     = 1/1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10,1/11,1/12,1/13,1/14,1/15,1/16,1/17,1/18,1/19,1/20,1/21,1/22,1/23,1/24,1/25,1/26,1/27,1/28,1/29,1/30,1/31,1/32,1/33,1/34,1/35,1/36,1/37,1/38,1/39,1/40,1/41,1/42,2/1,2/2,2/3,2/4,2/5,2/6,2/7,2/8,2/9,2/10,2/11,2/12,2/13,2/14,2/15,2/16,2/17,2/18,2/19,2/20,2/21,2/22,2/23,2/24,2/25,2/26,2/27,2/28,2/29,2/30,2/31,2/32,2/33,2/34,2/35,2/36,2/37,2/38,2/39,2/40,2/41,2/42
	
	VSP-8284XSQ:1#%
</pre>
<p>And on our same XOS:</p>
<pre>
	Slot-1 X460G2-STK.9 #% $allPorts = all
	
	$allPorts     = 1/1-54,2/1-54,3/1-34
	
	Slot-1 X460G2-STK.9 #% @vars raw $allPorts
	
	$allPorts     = 1/1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10,1/11,1/12,1/13,1/14,1/15,1/16,1/17,1/18,1/19,1/20,1/21,1/22,1/23,1/24,1/25,1/26,1/27,1/28,1/29,1/30,1/31,1/32,1/33,1/34,1/35,1/36,1/37,1/38,1/39,1/40,1/41,1/42,1/43,1/44,1/45,1/46,1/47,1/48,1/49,1/50,1/51,1/52,1/53,1/54,2/1,2/2,2/3,2/4,2/5,2/6,2/7,2/8,2/9,2/10,2/11,2/12,2/13,2/14,2/15,2/16,2/17,2/18,2/19,2/20,2/21,2/22,2/23,2/24,2/25,2/26,2/27,2/28,2/29,2/30,2/31,2/32,2/33,2/34,2/35,2/36,2/37,2/38,2/39,2/40,2/41,2/42,2/43,2/44,2/45,2/46,2/47,2/48,2/49,2/50,2/51,2/52,2/53,2/54,3/1,3/2,3/3,3/4,3/5,3/6,3/7,3/8,3/9,3/10,3/11,3/12,3/13,3/14,3/15,3/16,3/17,3/18,3/19,3/20,3/21,3/22,3/23,3/24,3/25,3/26,3/27,3/28,3/29,3/30,3/31,3/32,3/33,3/34
	
	Slot-1 X460G2-STK.9 #%
</pre>
<p>Note, if you wanted the variable to hold the string <i>"all"</i> instead, then simply put quotes around it.</p>
<p>Basically ACLI's port ranges will always adapt based on what is supported by the connected device. This is necessary, because we want to be able to dereference our variables directly into CLI commands for the device we are connected to. If ACLI were to use the wrong format of port range then the device would simply throw a syntax error on the CLI command and it would not be accepted.</p>
<p>In the case of a connected device which does not support port ranges at all (this was the case with the historical SecureRouter) then ACLI would not use any port ranges to display variables (author no longer has any SecureRouters for screenshots!) and would use a list format instead.</p>
<p>Two variable modifiers exist. The first one using the <i>$#</i> notation allows the variable to dereference not its value but the number of comma separated elements it holds. The second using the <i>$'</i> notation forces ACLI to dereference the variable in raw mode without attempting to compact the value in ranges</p>
<pre>
	VSP-8284XSQ:1#% $allPorts
	
	$allPorts     = 1/1-1/42,2/1-2/42
	
	VSP-8284XSQ:1#% $#allPorts
	
	$#allPorts    = 84
	
	VSP-8284XSQ:1#% $'allPorts
	
	$allPorts     = 1/1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10,1/11,1/12,1/13,1/14,1/15,1/16,1/17,1/18,1/19,1/20,1/21,1/22,1/23,1/24,1/25,1/26,1/27,1/28,1/29,1/30,1/31,1/32,1/33,1/34,1/35,1/36,1/37,1/38,1/39,1/40,1/41,1/42,2/1,2/2,2/3,2/4,2/5,2/6,2/7,2/8,2/9,2/10,2/11,2/12,2/13,2/14,2/15,2/16,2/17,2/18,2/19,2/20,2/21,2/22,2/23,2/24,2/25,2/26,2/27,2/28,2/29,2/30,2/31,2/32,2/33,2/34,2/35,2/36,2/37,2/38,2/39,2/40,2/41,2/42
	
	VSP-8284XSQ:1#%
</pre>
</div>



<div class="section" id="Capturing user variables">
<h2>Capturing user variables</h2>
<p>So we have seen that it is fairly easy to assign values to variables. However a much more compelling way to set the variables is to capture them directly from the output of CLI show commands. This is particularly useful when driving several ACLI sessions with the socket feature as it allows each ACLI session to correctly populate the same variable with device specific values.</p>
<p>To capture ports to a variable simply use the redirecton symbol '>' or '>>' followed by the destination variable.</p>
<pre>
	CLI show command &gt; $variable [-g]
	CLI show command &gt;&gt; $variable [-g]
</pre>
<p>If the variable was already set, use of '>' will result in the variable being overwritten with the newly captured values; whereas use of '>>' will result in the new captured values being comma appended to the existing values already held in the variable. The optional <i>-g</i> modifier allows capturing of all ports seen in every line of output, as opposed to only the first occurrence in each line of output.</p>
<p>Note, the redirect symbols '>'/'>>' followed by a variable does variable capturing; whereas the same redirect symbols '>'/'>>' followed by a file name does output redirection.</p>
<p>Variable capturing in its simplest form is only tuned for capturing port numbers in the output of CLI show commands. For example, if we wanted to capture all the SPB NNI ports on a VOSS switch we could simply use this:</p>
<pre>
	VSP8400-1:1#% isi > $nni
	       alias% show isis interface > $nni
	====================================================================================================
	                                ISIS Interfaces
	====================================================================================================
	IFIDX             TYPE    LEVEL     OP-STATE  ADM-STATE  ADJ    UP-ADJ  SPBM-L1-METRIC
	----------------------------------------------------------------------------------------------------
	Port2/1           pt-pt   Level 1   UP        UP         1      1       50
	Port2/2           pt-pt   Level 1   UP        UP         1      1       50
	Port2/3           pt-pt   Level 1   UP        UP         1      1       50
	Port2/4           pt-pt   Level 1   UP        UP         1      1       50
	Port3/17          pt-pt   Level 1   UP        UP         1      1       50
	Port3/18          pt-pt   Level 1   UP        UP         1      1       50
	
	--------------------------------------------------------------------------------
	 6 out of 6 Total Num of ISIS interfaces
	acli-dev.pl: Displayed Record Count = 6
	--------------------------------------------------------------------------------
	
	Var $nni = 2/1-2/4,3/17-3/18
	
	VSP8400-1:1#%
</pre>
<p>Or if we wanted simply to capture all ports with link up on the switch, we could do this:</p>
<pre>
	VSP8400-1:1#% ifup > $up
	       alias% show interfaces gigabitEthernet interface ||up\s+up > $up
	==========================================================================================
	                                      Port Interface
	==========================================================================================
	PORT                            LINK  PORT           PHYSICAL          STATUS
	NUM      INDEX DESCRIPTION      TRAP  LOCK     MTU   ADDRESS           ADMIN  OPERATE
	------------------------------------------------------------------------------------------
	2/1      256   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:20 up     up
	2/2      260   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:24 up     up
	2/3      264   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:28 up     up
	2/4      268   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:2c up     up
	2/5      272   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:30 up     up
	3/17     336   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:50 up     up
	3/18     340   40GbCR4          true  false    9600  b0:ad:aa:4f:0c:54 up     up
	
	Var $up = 2/1-2/5,3/17-3/18
	
	VSP8400-1:1#%
</pre>
<p>In general, we simply execute the show command we need, perhaps using grep to filter out only the ports we are interested in and then we capture those ports into a variable. So if we wanted to capture a variable with just the 40GbE ports on the switch we could do this:</p>
<pre>
	VSP8400-3:1#% if || 40G > $fast
	       alias% show interfaces gigabitEthernet interface!!locked || 40G > $fast
	==========================================================================================
	                                      Port Interface
	==========================================================================================
	PORT                            LINK  PORT           PHYSICAL          STATUS
	NUM      INDEX DESCRIPTION      TRAP  LOCK     MTU   ADDRESS           ADMIN  OPERATE
	------------------------------------------------------------------------------------------
	1/17     208   40GbNone         true  false    9600  64:6a:52:c5:5c:10 down   down
	1/18     212   40GbNone         true  false    9600  64:6a:52:c5:5c:14 down   down
	2/1      256   40GbCR4          true  false    9600  64:6a:52:c5:5c:20 up     up
	2/2      260   40GbCR4          true  false    9600  64:6a:52:c5:5c:24 up     up
	2/3      264   40GbNone         true  false    9600  64:6a:52:c5:5c:28 down   down
	2/4      268   40GbNone         true  false    9600  64:6a:52:c5:5c:2c down   down
	2/5      272   40GbSR4          true  false    9600  64:6a:52:c5:5c:30 up     up
	2/6      276   40GbNone         true  false    9600  64:6a:52:c5:5c:34 down   down
	3/17     336   40GbNone         true  false    9600  64:6a:52:c5:5c:50 down   down
	3/18     340   40GbCR4          true  false    9600  64:6a:52:c5:5c:54 up     up
	
	Var $fast = 1/17-1/18,2/1-2/6,3/17-3/18
	
	VSP8400-3:1#%
</pre>
<p>And if we wanted to append 100GbE ports to the same variable...</p>
<pre>
	VSP8400-3:1#% if || 100G >> $fast
	       alias% show interfaces gigabitEthernet interface!!locked || 100G >> $fast
	==========================================================================================
	                                      Port Interface
	==========================================================================================
	PORT                            LINK  PORT           PHYSICAL          STATUS
	NUM      INDEX DESCRIPTION      TRAP  LOCK     MTU   ADDRESS           ADMIN  OPERATE
	------------------------------------------------------------------------------------------
	4/1      384   100GbCR4         true  false    9600  64:6a:52:c5:5c:60 up     up
	4/2      385   100GbCR4         true  false    9600  64:6a:52:c5:5c:61 up     up
	
	Var $fast = 1/17-1/18,2/1-2/6,3/17-3/18,4/1-4/2
	
	VSP8400-3:1#%
</pre>
<p>Configuring these ports is now simply a matter of doing:</p>
<pre>
	VSP8400-3:1#% conf
	Configuring from terminal or network [terminal]?
	Enter configuration commands, one per line.  End with CNTL/Z.
	VSP8400-3:1(config)#% ife $fast
	                vars% ife 1/17-1/18,2/1-2/6,3/17-3/18,4/1-4/2
	               alias% interface gigabitEthernet 1/17-1/18,2/1-2/6,3/17-3/18,4/1-4/2
	VSP8400-3:1(config-if)#%
</pre>
<p>Capturing of port numbers will always extract the first occurrence of port numbers/list/range from each line of output. In the following example, only the port numbers in column 1 are captured and assigned to the <i>$p</i> variable:</p>
<pre>
	VSP8200-1:1#% tdp > $p
	       alias% show autotopology nmm-table !0/ *0 > $p
	==========================================================================================
	                                      Topology Table
	==========================================================================================
	Local                                                                              Rem
	Port     IpAddress       SegmentId MacAddress   ChassisType            BT LS  CS   Port
	------------------------------------------------------------------------------------------
	1/3      20.0.209.4      0x000131  b42d5653cc01 ERS4950GTS-PWR+        12 Yes HtBt  1/49
	1/41     20.0.0.11       0x000305  f873a20780d0 VSP8608                12 Yes HtBt  3/5
	1/42     20.0.0.12       0x000305  f873a203a0d0 VSP8608                12 Yes HtBt  3/5
	2/1      20.0.209.11     0x000131  b42d56556400 ERS4950GTS-PWR+        12 Yes HtBt  1/49
	2/2      20.0.209.12     0x000119  d4785607fc00 ERS5928GTS-UPWR        12 Yes HtBt  1/25
	2/3      20.0.209.13     0x000119  506184fbd000 ERS4826GTS-PWR+        12 Yes HtBt  1/25
	2/41     20.0.20.32      0x000229  b0adaa429468 VSP8284XSQ             12 Yes HtBt  2/41
	
	$p          = 1/3,1/41-1/42,2/1-2/3,2/41
	
	VSP8200-1:1#%
</pre>
<p>In older versions of ACLI, up to version 4.01, this was not the case and all ports in the above output would have been captured, including the port numbers listed in the last column. This was not hugely useful, as there is little use in mashing up the local and remote port numbers from the example above, so this behaviour has changed in ACLI 4.02. There could however be other cases where it might be desireable to do so, and so to obtain the old behaviour a <i>-g</i> modifier can be applied to variable port capturing, which if applied to the above example allows us to capture all ports anyway:</p>
<pre>
	VSP8200-1:1#% tdp > $p -g
	       alias% show autotopology nmm-table !0/ *0 > $p -g
	==========================================================================================
	                                      Topology Table
	==========================================================================================
	Local                                                                              Rem
	Port     IpAddress       SegmentId MacAddress   ChassisType            BT LS  CS   Port
	------------------------------------------------------------------------------------------
	1/3      20.0.209.4      0x000131  b42d5653cc01 ERS4950GTS-PWR+        12 Yes HtBt  1/49
	1/41     20.0.0.11       0x000305  f873a20780d0 VSP8608                12 Yes HtBt  3/5
	1/42     20.0.0.12       0x000305  f873a203a0d0 VSP8608                12 Yes HtBt  3/5
	2/1      20.0.209.11     0x000131  b42d56556400 ERS4950GTS-PWR+        12 Yes HtBt  1/49
	2/2      20.0.209.12     0x000119  d4785607fc00 ERS5928GTS-UPWR        12 Yes HtBt  1/25
	2/3      20.0.209.13     0x000119  506184fbd000 ERS4826GTS-PWR+        12 Yes HtBt  1/25
	2/41     20.0.20.32      0x000229  b0adaa429468 VSP8284XSQ             12 Yes HtBt  2/41
	
	$p          = 1/3,1/25,1/41-1/42,1/49,2/1-2/3,2/41,3/5
	
	VSP8200-1:1#%
</pre>
<p>Capturing ports into variables as shown above only works on devices which use a slot/port, or slot/port/channel or slot:port notation. So none of this will work on an ERS or an XOS standalone switch, since these number ports with a single decimal value, usually between 1-50. Given that switch CLI commands are full of numbers between 1-50 which are not referring to port numbers it would not be safe to try and capture these values into variables.</p>
<p>But there are a couple of other ways we can use to capture values to variables. These require the user to either specify which column of the output data to capture from or else to provide a regular expression to specify what and where to capture.</p>
<p>The first form is to follow the variable name with a '%' character immediately followed by the column number where we want to capture data. Columns are separated by one or more space characters.</p>
<pre>
	CLI show command &gt; $variable %&lt;n&gt;
</pre>
<p>This form is best used in conjunction with simple grep '|' in such a way to only display (and hence capture from) the lines where we have data to capture from, and eliminating the command's show banners which would otherwise become part of the capture data. Here below we capture the SPB NNI ports on an ERS standalone switch.</p>
<pre>
	ERS5900-FC#% isi
	      alias% show isis interface
	===============================================================================
	                                ISIS Interfaces
	===============================================================================
	IFIDX           TYPE    LEVEL    OP-STATE  ADM-STATE  ADJ UP-ADJ SPBM-L1-METRIC
	===============================================================================
	Port: 27        pt-pt   Level 1  UP        UP         1   1      200
	Port: 28        pt-pt   Level 1  UP        UP         1   1      200
	ERS5900-FC#%
	ERS5900-FC#% isi |Port: > $nni %2
	      alias% show isis interface |Port: > $nni %2
	Port: 27        pt-pt   Level 1  UP        UP         1   1      200
	Port: 28        pt-pt   Level 1  UP        UP         1   1      200
	
	Var $nni = 27-28
	
	ERS5900-FC#%
</pre>
<p>This method in fact becomes a very efficient method for extracting any data from CLI show comands. The simple grep selects the rows containing the data and the variable capture %&lt;n&gt determines the columns to read.</p>
<pre>
	VSP8400-3:1#% show snmp-server user
	Engine ID = 80:00:08:E0:03:64:6A:52:C5:5C:00
	
	====================================================================================================
	                               USM Configuration
	====================================================================================================
	User/Security Name    Engine Id                        Protocol
	----------------------------------------------------------------------------------------------------
	admin                0x80:00:08:E0:03:64:6A:52:C5:5C:00 HMAC_SHA, NO  PRIVACY
	adminaes             0x80:00:08:E0:03:64:6A:52:C5:5C:00 HMAC_SHA, AES PRIVACY,
	operator             0x80:00:08:E0:03:64:6A:52:C5:5C:00 HMAC_SHA, NO  PRIVACY
	
	3 out of 3 Total entries displayed
	acli.pl: Displayed Record Count = 4
	--------------------------------------------------------------------------------
	VSP8400-3:1#%
	VSP8400-3:1#% show snmp-server user |0x > $users %1
	admin                0x80:00:08:E0:03:64:6A:52:C5:5C:00 HMAC_SHA, NO  PRIVACY
	adminaes             0x80:00:08:E0:03:64:6A:52:C5:5C:00 HMAC_SHA, AES PRIVACY,
	operator             0x80:00:08:E0:03:64:6A:52:C5:5C:00 HMAC_SHA, NO  PRIVACY
	
	Var $users = admin,adminaes,operator
	
	VSP8400-3:1#%
</pre>
<p>The same variable capture syntax can also be used to capture the data in two or more columns into the same variable, using these syntaxes:</p>
<pre>
	CLI show command &gt; $variable %&lt;n1&gt;[%&lt;n2&gt;]...
	CLI show command &gt; $variable %&lt;n1&gt;-[%&lt;n3&gt;]...
</pre>
<p>The '%' cloumn indicators can be concatenated, e.g. '%1%3', or comma separated, '%1,%3'. Ranges are also allowed, like '%1-%5', as well an unbounded ranges, like '%5-', which will result in the data in all columns from column 5 onwards to be captured. A few examples:</p>
<pre>
	VSP8600-1:1#% show license |License granted for slots > $slots %6%7%8
	        License granted for slots        : 1  2  3  4  5  6  7  8
	
	
	Var $slots = 1-3
	
	VSP8600-1:1#%
</pre>
<pre>
	VSP8600-1:1#% show license |License granted for slots > $slots %6-%13
	        License granted for slots        : 1  2  3  4  5  6  7  8
	
	
	Var $slots = 1-8
	
	VSP8600-1:1#%
</pre>
<pre>
	VSP8600-1:1#% show license |License granted for slots > $slots %6-
	        License granted for slots        : 1  2  3  4  5  6  7  8
	
	
	Var $slots = 1-8
	
	VSP8600-1:1#%
</pre>
<p>Another variant of the same syntax allows multiple variables to be captured in the same CLI command.</p>
<pre>
	CLI show command &gt; $variable1,$variable2,... %&lt;n1&gt;%&lt;n2&gt;...
	CLI show command &gt; $variable1,$variable2,$variable3... %&lt;n1&gt;-%&lt;n3&gt;
</pre>
<p>Again, the '%' cloumn indicators can be concatenated, e.g. '%1%3', or comma separated, '%1,%3' or defined as ranges, '%1-%5'. Though unbounded ranges are not allowed here. In general with this syntax ACLI will check to make sure that the number of '%' columns requested in the variable capture command matches the number of capture variables provided. If the number is not the same, then the command is not accepted with an error. An example:</p>
<pre>
	VSP8400-3:1#% lldn
	       alias% show lldp neighbor summary
	========================================================================================================================
	                                                 LLDP Neighbor Summary
	========================================================================================================================
	LOCAL            IP              CHASSIS            REMOTE
	PORT       PROT  ADDR            ID                 PORT               SYSNAME       SYSDESCR
	------------------------------------------------------------------------------------------------------------------------
	2/1        LLDP  20.0.10.73      a4:25:1b:52:24:00  2/1                VSP7200-3     VSP-7254XSQ (7.1.0.0)
	2/2        LLDP  20.0.10.74      a4:78:86:fb:e0:00  2/1                VSP7200-4     VSP-7254XSQ (7.1.0.0)
	2/5        LLDP  20.0.109.12     00:04:96:a5:12:72  49                 X690-2        ExtremeXOS (X690-48x-2q-4c) v~
	3/18       LLDP  20.0.10.21      b0:ad:aa:4f:0c:00  3/18               VSP8400-1     VSP-8404 (7.1.0.0)
	4/1        LLDP  20.0.0.11       f8:73:a2:07:80:00  1/3                VSP8600-1     VSP-8608 (6.2.0.0_B069) (TRIA~
	4/2        LLDP  20.0.0.12       f8:73:a2:03:a0:00  1/3                VSP8600-2     VSP-8608 (6.2.0.0_B069) (TRIA~
	------------------------------------------------------------------------------------------------------------------------
	Total Neighbors : 6
	VSP8400-3:1#% lldn | LLDP  \d > $locPort,$remport %1,%5
	       alias% show lldp neighbor summary | LLDP > $locPort,$remport %1,%5
	2/1        LLDP  20.0.10.73      a4:25:1b:52:24:00  2/1                VSP7200-3     VSP-7254XSQ (7.1.0.0)
	2/2        LLDP  20.0.10.74      a4:78:86:fb:e0:00  2/1                VSP7200-4     VSP-7254XSQ (7.1.0.0)
	2/5        LLDP  20.0.109.12     00:04:96:a5:12:72  49                 X690-2        ExtremeXOS (X690-48x-2q-4c) v~
	3/18       LLDP  20.0.10.21      b0:ad:aa:4f:0c:00  3/18               VSP8400-1     VSP-8404 (7.1.0.0)
	4/1        LLDP  20.0.0.11       f8:73:a2:07:80:00  1/3                VSP8600-1     VSP-8608 (6.2.0.0_B069) (TRIA~
	4/2        LLDP  20.0.0.12       f8:73:a2:03:a0:00  1/3                VSP8600-2     VSP-8608 (6.2.0.0_B069) (TRIA~
	
	Var $locPort = 2/1-2/2,2/5,3/18,4/1-4/2
	Var $remport = 1/3,2/1,3/18,49
	
	VSP8400-3:1#%
</pre>

<p>The other form to do variable capturing is to use regular expressions with grouping brackets '()'. The syntax is the following:</p>
<pre>
	CLI show command &gt; $variable1,$variable2,... '&lt;regex&gt;'[ig]
	CLI show command &gt; $variable1,$variable2,... '&lt;regex&gt;' [-ig]
</pre>
<p>Where <i>'&lt;regex&gt;'</i> is the regular expression which must include as many grouping brackets '()' as there are variables to capture. The regex should be provided inside single quotes and the closing quote can be optionally followed by a lower case 'i', which will make the regex patterns case insensitive, or a lower case 'g' which will allow the regex to match multiple times per line of output. Both the 'i' and 'g' modifiers can also be provided as <i>-i</i> or <i>-g</i> following the regex.</p>
<p>This form is useful when the data to capture is not nicely delimited by spaces. Follows an example:</p>
<pre>
	Slot-1 X460G2-STK.8 #% show log configuration |'syslog;' > $ip,$port '(\d+\.\d+\.\d+\.\d+):(\d+)'
	Log Target      : syslog; 10.8.255.15:514 (vr VR-Mgmt), local0
	
	$ip         = 10.8.255.15
	$port       = 514
	
	Slot-1 X460G2-STK.9 #%
</pre>
<p>In general, the same form can be used if one wishes to capture output for separate variables even if the values appear on separate lines. In the following example, we capture all the L2VSN and L3VSN I-SIDs used by a particular fabric node by dumping the ISIS LSDB; the list of ISIDs is to be stored in two separate variables, for L2 and L3, but the values we intend to capture will appear on different output lines (i.e. we will not get a both a L3 I-SID and a L2 I-SID value on the same line of output); so the provided <i>regex</i> will need to provide alternate patterns separated by the '|' character. In addition to that, there are multiple L2 I-SID values listed on the same line of output, so we need our capturing regular expression to capture all occurrencies on each line (not just the first one) so we also add the <i>g</i> flag to the capture regex:</p>
<pre>
	VSP8400-1:1#% show isis lsdb sysid 82bb.0000.2100 detail |Both,Rx,Tx,Vrf ISID: -s > $l2isid,$l3isid '(\d+)\(|Vrf ISID:(\d+)'g
	                        16000000(Rx),16777215(None)
	                        2800100(Rx),2800101(Rx),2800104(Rx),2800109(Rx),2800110(Rx),2800111(Rx),2800120(Rx),2800130(Rx)
	                        2800190(Rx),2800191(Rx),2801111(Rx),10002122(Rx)
	                        2800100(Both),2800101(Both),2800104(Both),2800109(Both),2800110(Both),2800111(Both),2800120(Both),2800130(Both)
	                        2800190(Both),2800191(Both),2801111(Both),10002122(Both),16678216(Both),16678217(Both)
	                Vrf ISID:3800001
	                Vrf ISID:3800002
	                Vrf ISID:3800003
	                Vrf ISID:3800009
	
	
	$l2isid     = 2800100-2800101,2800104,2800109-2800111,2800120,2800130,2800190-2800191,2801111,10002122,16000000,16678216-16678217,16777215
	$l3isid     = 3800001-3800003,3800009
	
	VSP8400-1:1#%
</pre>
<p>The above example is also used by the pre-defined <i>'dbisid'</i> alias.</p>
</div>



<div class="section" id="Advanced user variables">
<h2>Advanced user variables</h2>
<p>The above sections have so far only covered ACLI simple (scalar) variables, wihch for most uses are sufficient. Yet for storing data in a structured order or one value in relation to another this is only possible with arrays or hashes. So ACLI supports both arrays and hashes as well.</p>
<p>Array variables are denoted by simply appending '[]' to a regular user variable name:</p>
<pre>
	$list[]
</pre>
<p>Hash variables are denoted by appending '{}':</p>
<pre>
	$hash{}
</pre>
<p>Note that ACLI only supports one variable namespace, so a given variable name can have values assigned either as a list or hash or a scalar. Hence assigning a value to <i>$list</i> would erase the above array and relace it with a scalar.</p>
</div>




<div class="section" id="Setting array variables">
<h3>Setting array variables</h3>
<p>In practice array variables will typically get set by capturing a list of values from the output of some CLI command, and this will be covered in the section below. Nevertheless, a syntax is available to manually assign a list of values to an array variable.</p>
<pre>
	VSP-8284XSQ:1#% $list[] = (1/1-1/10; 1,2,3; string)
	
	$list[]     = (1/1-1/10; 1-3; string)
	
	VSP-8284XSQ:1#%
</pre>
<p>Each element of the array can take the same values and follows the same rules as scalar variables which have been covered in the preceding sections.</p>
<p>Note that ACLI arrays are 1-based so 1 is the index for the first element in the array. The 0 index is allowed but will return the last element in the array. Negative index values are not allowed.</p>
<pre>
	VSP-8284XSQ:1#% $list[1]
	
	$list[1]    = 1/1-1/10
	
	VSP-8284XSQ:1#% $list[2]
	
	$list[2]    = 1-3
	
	VSP-8284XSQ:1#% $list[3]
	
	$list[3]    = string
	
	VSP-8284XSQ:1#% $list[0]
	
	$list[3]    = string
	
	VSP-8284XSQ:1#%
</pre>
<p>Array values can also be directly assigned to an index value, as long as the index provided is already within the array or it increases the array size by 1.</p>
<pre>
	VSP-8284XSQ:1#% $list[3] = newstring
	
	$list[3]    = newstring
	
	VSP-8284XSQ:1#% $list[4] = 99
	
	$list[4]    = 99
	
	VSP-8284XSQ:1#% $list
	
	$list[]     = (1/1-1/10; 1-3; newstring; 99)
	
	VSP-8284XSQ:1#%
</pre>
<p>Note from the above example that we have replaced the value of the 3rd and last element and we have appended a new element increasing the size of the array by 1. This allows us to grow arrays in iteration loops while preventing a user from creating an array with a multi-million index (which would cause an out of memory error!)</p>
<p>The size of the array can be obtained with the <i>$#</i> notation:</p>
<pre>
	VSP-8284XSQ:1#% $#list
	
	$#list      = 4
	
	VSP-8284XSQ:1#% @print $list[$#list]
	          vars% @print 99
	99
	
	VSP-8284XSQ:1#% $list[0]
	
	$list[4]    = 99
	
	VSP-8284XSQ:1#%
</pre>
<p>While the same <i>$#</i> and <i>$'</i> notations can still be used on individual elements of the array, if they are comma separated values, just as we could do for scalar variables:</p>
<pre>
	VSP-8284XSQ:1#% $list[1]
	
	$list[1]    = 1/1-1/10
	
	VSP-8284XSQ:1#% $'list[1]
	
	$list[1]    = 1/1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10
	
	VSP-8284XSQ:1#% $#list[1]
	
	$#list[1]   = 10
	
	VSP-8284XSQ:1#%
</pre>
<p>Whereas if the array is dereferenced without an index in a CLI command then a comma separated list of the index numbers will be applied.</p>
<pre>
	VSP-8284XSQ:1#% @print $list[]
	          vars% @print 1,2,3,4
	1,2,3,4
	
	VSP-8284XSQ:1#%
</pre>
<p>Note that this property also allows us to iterate through the array in a <i>@for</i> loop:</p>
<pre>
	@echo off
	@for $i &$list[]
	   @printf "Index %s has value = %s", $i, $list[$i]
	@endfor
	@echo on
</pre>
<p>Which produces this output:</p>
<pre>
	VSP-8284XSQ:1#%  @echo off
	Index 1 has value = 1/1-1/10
	Index 2 has value = 1-3
	Index 3 has value = newstring
	Index 4 has value = 99
	VSP-8284XSQ:1#%
</pre>
</div>



<div class="section" id="Setting hash variables">
<h3>Setting hash variables</h3>
<p>In practice hash variables will typically get set by capturing a list of values from the output of some CLI command, and this will be covered in the section below. Nevertheless, a syntax is also available to manually assign a key/value pairs to a hash variable.</p>
<pre>
	VSP-8284XSQ:1#% $hash{} = (ports => 2/1-2/5; numbers => 1-10; name => string)
	
	$hash{}     = (name=>string; numbers=>1-10; ports=>2/1-2/5)
	
	VSP-8284XSQ:1#%
</pre>
<p>Each hash element can take the same values and follows the same rules as scalar variables which have been covered in the preceding sections. The order of the hash keys is not necessarily the order in which the hash keys were entered; ACLI will list the hash keys in alphabetical order.</p>
<p>Hash elements can be recalled or overwritten with a new value by specifying the hash key.</p>
<pre>
	VSP-8284XSQ:1#% $hash{ports}
	
	$hash{ports} = 2/1-2/5
	
	VSP-8284XSQ:1#% $hash{numbers} = 1-20
	
	$hash{numbers} = 1-20
	
	VSP-8284XSQ:1#% $hash{new} = 99
	
	$hash{new}  = 99
	
	VSP-8284XSQ:1#% $hash{}
	
	$hash{}     = (name=>string; new=>99; numbers=>1-20; ports=>2/1-2/5)
	
	VSP-8284XSQ:1#%
</pre>
<p>The number of key/value pairs in the hash can again be obtained with the <i>$#</i> notation:</p>
<pre>
	VSP-8284XSQ:1#% $#hash
	
	$#hash      = 4
	
	VSP-8284XSQ:1#%
</pre>
<p>And like with arrays, the same <i>$#</i> and <i>$'</i> notations can still be used on individual elements of the hash, if they are comma separated values, just as we could do for scalar variables:</p>
<pre>
	VSP-8284XSQ:1#% $hash{ports}
	
	$hash{ports} = 2/1-2/5
	
	VSP-8284XSQ:1#% $'hash{ports}
	
	$hash{ports} = 2/1,2/2,2/3,2/4,2/5
	
	VSP-8284XSQ:1#% $#hash{ports}
	
	$#hash{ports} = 5
	
	VSP-8284XSQ:1#%
</pre>
<p>Whereas if the hash is dereferenced without a key in a CLI command then a comma separated list of the keys will be applied.</p>
<pre>
	VSP-8284XSQ:1#% @print $hash{}
	          vars% @print name,new,numbers,ports
	name,new,numbers,ports
	
	VSP-8284XSQ:1#%
</pre>
<p>Note that this property also allows us to iterate through the hash in a <i>@for</i> loop:</p>
<pre>
	@echo off
	@for $key &$hash{}
	   @printf "Key '%s' has value = %s", $key, $hash{$key}
	@endfor
	@echo on
</pre>
<p>Which produces this output:</p>
<pre>
	VSP-8284XSQ:1#%  @echo off
	Key 'name' has value = string
	Key 'new' has value = 99
	Key 'numbers' has value = 1-20
	Key 'ports' has value = 2/1-2/5
	VSP-8284XSQ:1#%
</pre>
</div>



<div class="section" id="Capturing to list & hash variables">
<h3>Capturing to list & hash variables</h3>
<p>This section will look at how we can populate array and hash variables with values directly from the output of a CLI command. All the concepts already covered in the above section where variable capturing was covered for scalar variables still appy here.</p>
<p>As a first example let us capture all our 40G ports and their respective ifIndex into two separate arrays.</p>
<pre>
	VSP-8284XSQ:1#% if |40G > $port[],$ifdx[] %1%2
	         alias% show interfaces gigabitEthernet interface!!locked |40G > $port[],$ifdx[] %1%2
	1/41     232   40GbNone            true  false    1950  00:51:00:3f:a8:28 down   down
	1/42     236   40GbNone            true  false    1950  00:51:00:3f:a8:2c down   down
	2/41     296   40GbNone            true  false    1950  00:51:00:3f:a8:68 down   down
	2/42     300   40GbNone            true  false    1950  00:51:00:3f:a8:6c down   down
	
	$port[]     = (1/41; 1/42; 2/41; 2/42)
	$ifdx[]     = (232; 236; 296; 300)
	
	VSP-8284XSQ:1#%
</pre>
<p>We could have used scalar variables but the advantage of using arrays is that we can now easily iterate through the values in a <i>@for</i> loop. By copy-pasting the following script:</p>
<pre>
	@echo off
	@for $i &$port[]
	   @printf "Port %s has ifIndex %s", $port[$i], $ifdx[$i]
	@endfor
	@echo on
</pre>
<p>We get the following output:</p>
<pre>
	VSP-8284XSQ:1#%  @echo off
	Port 1/41 has ifIndex 232
	Port 1/42 has ifIndex 236
	Port 2/41 has ifIndex 296
	Port 2/42 has ifIndex 300
	VSP-8284XSQ:1#%
</pre>
<p>This works nicely as we know that both arrays have the exact same number of elements.</p>
<p>An example where arrays come in handy is if we wanted to capture port membership for some different record type, but wanted the port list/ranges not to get merged. For example:</p>
<pre>
	PoE-TUNI-Switch:1#% show i-sid > $isids[],$ports[] %1,%4
	==========================================================================================
	                                        Isid Info
	==========================================================================================
	ISID        ISID                    PORT               MLT                ORIGIN
	ID          TYPE       VLANID       INTERFACES         INTERFACES
	------------------------------------------------------------------------------------------
	15999003    ELAN_TR    N/A          1/3,1/41           -                  CONFIG
	15999004    ELAN_TR    N/A          1/4,1/47           -                  CONFIG
	15999005    ELAN_TR    N/A          1/5,1/46           -                  CONFIG
	15999006    ELAN_TR    N/A          1/6,1/39           -                  CONFIG
	15999007    ELAN_TR    N/A          1/7,1/43           -                  CONFIG
	15999008    ELAN_TR    N/A          1/8,1/42           -                  CONFIG
	15999009    ELAN_TR    N/A          1/9,1/45           -                  CONFIG
	15999010    ELAN_TR    N/A          1/10,1/37          -                  CONFIG
	15999012    ELAN_TR    N/A          1/12,1/38          -                  CONFIG
	15999014    ELAN_TR    N/A          1/14,1/33          -                  CONFIG
	15999015    ELAN_TR    N/A          1/15,1/30          -                  CONFIG
	15999016    ELAN_TR    N/A          1/16,1/29          -                  CONFIG
	15999017    ELAN_TR    N/A          1/17,1/31          -                  CONFIG
	15999018    ELAN_TR    N/A          1/18,1/32          -                  CONFIG
	15999019    ELAN_TR    N/A          1/19,1/44          -                  CONFIG
	15999025    ELAN_TR    N/A          1/25,1/50          -                  CONFIG
	15999026    ELAN_TR    N/A          1/26,1/49          -                  CONFIG
	
	c: customer vid    u: untagged-traffic
	All 17 out of 17 Total Num of i-sids displayed
	acli.pl: Displayed Record Count = 17
	
	$isids[]    = (15999003; 15999004; 15999005; 15999006; 15999007; 15999008; 15999009; 15999010; 15999012; 15999014; 15999015; 15999016; 15999017; 15999018; 15999019; 15999025; 15999026)
	$ports[]    = (1/3,1/41; 1/4,1/47; 1/5,1/46; 1/6,1/39; 1/7,1/43; 1/8,1/42; 1/9,1/45; 1/10,1/37; 1/12,1/38; 1/14,1/33; 1/15,1/30; 1/16,1/29; 1/17,1/31; 1/18,1/32; 1/19,1/44; 1/25,1/50; 1/26,1/49)
	
	PoE-TUNI-Switch:1#%
</pre>
<p>If we had used a scalar variable, the ports would have all got mashed into one combined list.</p>
<p>However a hash is often the most efficient way to capture values and associate them with a key value. The above first example where we captured the all the 40G port numbers and their respective ifIndexes into two separate arrays could have been done using a single hash, as in the following example:</p>
<pre>
	VSP-8284XSQ:1#% if |40G > $portIfdx{%1} %2
	         alias% show interfaces gigabitEthernet interface!!locked |40G > $portIfdx{%1} %2
	1/41     232   40GbNone            true  false    1950  00:51:00:3f:a8:28 down   down
	1/42     236   40GbNone            true  false    1950  00:51:00:3f:a8:2c down   down
	2/41     296   40GbNone            true  false    1950  00:51:00:3f:a8:68 down   down
	2/42     300   40GbNone            true  false    1950  00:51:00:3f:a8:6c down   down
	
	$portIfdx{} = (1/41=>232; 1/42=>236; 2/41=>296; 2/42=>300)
	
	VSP-8284XSQ:1#%
</pre>
<p>Now we have a hash where the key is the port number and the values are the corresponding ifIndexes. Notice how we can specify which column value is to be used as the hash key, by simply using the <i>%&lt;n&gt;</i> syntax within the hash curlies. Perhaps we might like to also record the MAC address of each 40G port. This can be easily done by capturing to a second hash, using the same key:</p>
<pre>
	VSP-8284XSQ:1#% if |40G > $portIfdx{%1},$portMac{%1} %2%7
	         alias% show interfaces gigabitEthernet interface!!locked |40G > $portIfdx{%1},$portMac{%1} %2%7
	1/41     232   40GbNone            true  false    1950  00:51:00:3f:a8:28 down   down
	1/42     236   40GbNone            true  false    1950  00:51:00:3f:a8:2c down   down
	2/41     296   40GbNone            true  false    1950  00:51:00:3f:a8:68 down   down
	2/42     300   40GbNone            true  false    1950  00:51:00:3f:a8:6c down   down
	
	$portIfdx{} = (1/41=>232; 1/42=>236; 2/41=>296; 2/42=>300)
	$portMac{}  = (1/41=>00:51:00:3f:a8:28; 1/42=>00:51:00:3f:a8:2c; 2/41=>00:51:00:3f:a8:68; 2/42=>00:51:00:3f:a8:6c)
	
	VSP-8284XSQ:1#%
</pre>
<p>We could now iterate over our hashes using a similar script, which we will copy-paste to ACLI:</p>
<pre>
	@echo off
	@for $key &$portIfdx{}
	   @printf "Port %s has ifIndex %s and MAC %s", $key, $portIfdx{$key}, $portMac{$key}
	@endfor
	@echo on
</pre>
<p>Which gives us the following output:</p>
<pre>
	VSP-8284XSQ:1#%  @echo off
	Port 1/41 has ifIndex 232 and MAC 00:51:00:3f:a8:28
	Port 1/42 has ifIndex 236 and MAC 00:51:00:3f:a8:2c
	Port 2/41 has ifIndex 296 and MAC 00:51:00:3f:a8:68
	Port 2/42 has ifIndex 300 and MAC 00:51:00:3f:a8:6c
	VSP-8284XSQ:1#%
</pre>
<p>It therefore becomes possible to create completely new CLI commands, by first extracting the desired information into array or hashes, and then <i>@print</i>-ing it out via a script, all contained in a single command alias!</p>
<p>Another example is if we wanted to have two separate hashes, the 1st one giving us the ifIndex of a given port and the other doing the opposite, i.e. giving us the port number for a given ifIndex:</p>
<pre>
	VSP-8284XSQ:1#% if |40G > $portIfdx{%1},$ifdxPort{%2} %2%1
	         alias% show interfaces gigabitEthernet interface!!locked |40G > $portIfdx{%1},$ifdxPort{%2} %2%1
	1/41     232   40GbNone            true  false    1950  00:51:00:3f:a8:28 down   down
	1/42     236   40GbNone            true  false    1950  00:51:00:3f:a8:2c down   down
	2/41     296   40GbNone            true  false    1950  00:51:00:3f:a8:68 down   down
	2/42     300   40GbNone            true  false    1950  00:51:00:3f:a8:6c down   down
	
	$portIfdx{} = (1/41=>232; 1/42=>236; 2/41=>296; 2/42=>300)
	$ifdxPort{} = (232=>1/41; 236=>1/42; 296=>2/41; 300=>2/42)
	
	VSP-8284XSQ:1#%
	VSP-8284XSQ:1#% $portIfdx{1/42}
	
	$portIfdx{1/42} = 236
	
	VSP-8284XSQ:1#% $ifdxPort{236}
	
	$ifdxPort{236} = 1/42
	
	VSP-8284XSQ:1#%
</pre>
<p>Capturing with regular expressions can be used to capture the hash key on a different line from the actualy hash key value. The ERS <i>show vlan</i> output is a perfect example where the VLAN port membership is displayed on the line below the VLAN record. To capture each VLAN's port membership we can do the following:</p>
<pre>
	ERS4900-STK#% show vlan > $vlanPorts{%1} '^(\d+)|(\d[\d/,-]+\d)'
	Id   Name                 Type     Protocol         PID     Active IVL/SVL Mgmt
	---- -------------------- -------- ---------------- ------- ------ ------- ----
	1    VLAN #1              Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/1-8,1/10,1/12-48,1/50,2/1-8,2/10,2/12-15,2/17-48,3/1-4,3/6-48,3/50
	200  VLAN #200            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/9,1/49,2/11,3/5,3/49
	201  VLAN #201            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/49,2/11,3/49
	209  VLAN #209            Port     None             0x0000  Yes    IVL     Yes
	        Port Members: 1/49,2/16,2/50,3/6
	210  VLAN #210            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/49,2/9,3/6,3/49
	211  VLAN #211            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/49,3/49
	220  VLAN #220            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/49,3/5-6,3/49
	230  VLAN #230            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/49,3/6,3/49
	240  VLAN #240            Port     None             0x0000  Yes    IVL     No
	        Port Members: 1/11,1/49,3/49
	Total VLANs: 9
	
	$vlanPorts{} = (1=>1/1-8,1/10,1/12-48,1/50,2/1-8,2/10,2/12-15,2/17-48,3/1-4,3/6-48,3/50; 200=>1/9,1/49,2/11,3/5,3/49; 201=>1/49,2/11,3/49; 209=>1/49,2/16,2/50,3/6; 210=>1/49,2/9,3/6,3/49; 211=>1/49,3/49; 220=>1/49,3/5-6,3/49; 230=>1/49,3/6,3/49; 240=>1/11,1/49,3/49)
	
	ERS4900-STK#%
</pre>
<p>Another similar challenging output is the VSP <i>"show i-sid"</i> output. Follows an example using regular expressions to capture the ports by I-SID:</p>
<pre>
	VSP-8284XSQ:1#% show i-sid > $isidPorts{%1} '(^\d+)\s+\S+\s+\S+\s+[uc\d]+:(\d[\d/,-]+\d)|\s{36,}(\d[\d/,-]+\d)'
	==========================================================================================
	                                        Isid Info
	==========================================================================================
	ISID        ISID                    PORT               MLT                ORIGIN
	ID          TYPE       VLANID       INTERFACES         INTERFACES
	------------------------------------------------------------------------------------------
	666666      ELAN       N/A          c10:1/11,          -                  CONFIG
	                                    1/13-1/15,1/17,
	                                    1/19-1/21,1/23
	777777      ELAN       N/A          c20:1/10-1/15,     -                  CONFIG
	                                    1/25
	
	c: customer vid    u: untagged-traffic
	All 2 out of 2 Total Num of i-sids displayed
	
	$isidPorts{} = (666666=>1/11,1/13-1/15,1/17,1/19-1/21,1/23; 777777=>1/10-1/15,1/25)
	
	VSP-8284XSQ:1#%
</pre>
</div>


<div class="section" id="Querying user to set variable">
<h2>Querying user to set variable</h2>
<p>Another way to assign values to variables is to prompt the user for a value. ACLI offers the <i>'@vars prompt'</i> embedded command to do this.</p>
<pre>
	@vars prompt [optional] [ifunset] &lt;$variable&gt; ["Text to prompt user with"]
</pre>
<p>If <i>'optional'</i> is specified, then the user can chose to not provide any value by just hitting enter. In which case, if the variable supplied was already set, it will be unset (deleted). Also, in scripting mode, script execution will continue if user hits enter with no input. If instead the 'optional' argument is not specified then the user is expected to enter a value and if nothing is entered then ACLI will come out of scripting mode.</p>
<p>If <i>'ifunset'</i> is specified, then the user is queried for a value only if the variable in question does not exist (i.e. it is not set yet). If the variable is already set, then '@vars prompt' does nothing.</p>
<p>If no <i>"Text to prompt user with"</i> is provided, the user will be prompted with a standard message to set the named variable. The '@vars prompt' is typically used in ACLI scripts to obtain user input, as such the user need not know about the variable names used by the script, and it is more user friendly to just ask the user for the information required.</p>
<p>The <i>&lt;$variable&gt;</i> will typically be a regular scalar variable. It can also be a hash or array variable, but in this case it has to be for either a specific hash key or a specific array element number, because only a single value can be entered by the user.</p>
<p>A few examples. We will use the following script:</p>
<pre>
	@vars prompt $input
	$input
</pre>
<p>To test the script, simply copy-paste it into ACLI</p>
<pre>
	VSP-8284XSQ:1#% @vars prompt $input
	Please enter a value for $input : 42
	VSP-8284XSQ:1#% $input
	
	$input      = 42
	
	VSP-8284XSQ:1#%
</pre>
<p>A value was supplied, and the script executed the second and last line, to show the variable.</p>
<pre>
	VSP-8284XSQ:1#% @vars prompt $input
	Please enter a value for $input :
	VSP-8284XSQ:1#%
</pre>
<p>The same script was executed, but this time user simply hit return and provided no value. This is unexpected so ACLI exits from scripting mode. Note that the second line did not execute.</p>
<p>Let's change the script to this:</p>
<pre>
	@vars prompt optional $input
	$input
</pre>
<p>We execute the script, and provide no value.</p>
<pre>
	VSP-8284XSQ:1#% @vars prompt optional $input
	Please enter a value for $input [enter to unset]:
	VSP-8284XSQ:1#% $input
	
	$input      = &lt;undefined&gt;
	
	VSP-8284XSQ:1#%
</pre>
<p>Notice that the scripts completes execution in this case.</p>
<pre>
	VSP-8284XSQ:1#% @vars prompt optional $input
	Please enter a value for $input [enter to skip]:  42
	VSP-8284XSQ:1#% $input
	
	$input      = 42
	
	VSP-8284XSQ:1#%
</pre>
<p>No difference if a value is provided.</p>
<p>Note, if we wanted to keep prompting the user until a valid value is entered, then it is sufficient to enclose the '@vars prompt' in a '@until' loop. Here's a new script example.</p>
<pre>
	@echo off
	@loop
		@vars prompt optional $_ "Are you sure you want to continue (y/n) ?"
	@until $_ =~ /[Yy](es)?/ || $_ =~ /[Nn]o?/
	@printf "User said : %s", $
	@echo on
</pre>
<p>The <i>'@echo off'</i> tells ACLI to stop echoing the switch prompts and the script commands as they are executed, so as to remove clutter during script execution (this is covered in the scripting section). Notice that a custom prompt is provided here.</p>
<pre>
	VSP-8284XSQ:1#% @echo off
	Are you sure you want to continue (y/n) ?
	Are you sure you want to continue (y/n) ?
	Are you sure you want to continue (y/n) ?
	Are you sure you want to continue (y/n) ?
	Are you sure you want to continue (y/n) ? n
	User said : n
	VSP-8284XSQ:1#%
</pre>
<p>Note that now, the user has no choice but to provide a valid answer, either yes or no (user can still break out of the script using CTRL-C). The answer is held in the default variable '$_' in this example.</p>
<p>Let's change our script back to the simple example, but this time with the <i>'ifunset'</i> argumnet:</p>
<pre>
	@vars prompt ifunset $input
	$input
</pre>
<p>Which gives:</p>
<pre>
	VSP-8284XSQ:1#% @vars prompt ifunset $input
	VSP-8284XSQ:1#% $input
	
	$input      = 42
	
	VSP-8284XSQ:1#%
</pre>
<p>Notice that we were not even prompted for a value for <i>$input</i>, since the variable was already set in our case.</p>
</div>



<div class="section" id="Reserved variables">
<h2>Reserved variables</h2>
<p>The ACLI terminal has some reserved variables which cannot be used as user variables. These variable are typically read-only (except exceptions!) and their values are set by ACLI.</p>
<ul>
	<li><b>$$</b> : Device system name. Same as attribute variable '$_sysname' when available else ACLI automatically extracts the switch name from the device's CLI prompt (this happens only on PassportERS Standby CPUs). Because this variable is often used to redirect output to a file named after the switch (e.g. <i>$$.cfg</i>) if the switch name includes any special character which cannot be used in a filename, these characters will be replaced with an underscore '_'. (To get the unmodified switch hostname, consider using the attribute variable '$_sysname' as an alternative).
	<pre>
	VSP-8284XSQ:1#% $$
	
	$$          = VSP-8284XSQ
	
	VSP-8284XSQ:1#%
	</pre></li>
	<li><b>$%</b> : Switch index number. If ACLI sessions are tied together using socket functionality and the switch prompts (names) are numbered (e.g. Switch-1, Switch-2, Switch-3, etc...) then on each ACLI session '$%' will take value = 1, 2, 3, etc..</li>
	<li><b>$@</b> : Last error message. If last switch CLI command generated an error message, this variable holds the error message. This is useful in ACLI scripting mode, when error detection is disabled ('@error disable') and the script needs to figure out if the previous command failed, without terminating the script. This variable can be primed, i.e. user can set a value to it. Note however that this value is set or reset after every CLI command sent to the connected device, so it needs to be checked immediately after the CLI command we want to check for error messages.
	<pre>
	VSP-8284XSQ:1#% doctor Foster went to Gloucester
	                  ^
	% Invalid input detected at '^' marker.
	VSP-8284XSQ:1#% $@
	
	$@          = Invalid input detected at ^ marker.
	
	VSP-8284XSQ:1#% pwd
	/intflash
	VSP-8284XSQ:1#% $@
	
	$@          = &lt;undefined&gt;
	
	VSP-8284XSQ:1#%
	</pre></li>
	<li><b>$></b> : Last CLI prompt from connected device. Useful to create logic to move between different CLI exec levels using ACLI scripts.</li>
	<li><b>$&lt;number&gt;</b> : When sourcing a script with <i>'@source'</i> or <i>'@run'</i>, holds positional argument number provided to script.</li>
	<li><b>$*</b> : When sourcing a script with <i>'@source'</i> or <i>'@run'</i>, holds concatenated arguments provided to script.</li>
	<li><b>$ALL</b> : This variable will always translate to all the ethernet ports on the connected device.</li>
	<li><b>$&lt;number&gt;/ALL</b> : This variable will always translate to all the ethernet ports on the specified slot number of the connected device. For example $1/ALL will translate to all ports on slot 1.</li>
	<li><b>$&lt;number&gt;:ALL</b> : Same as above, but using the ExtremeXOS slot:port notation, will translate to all the ethernet ports on the specified slot number of the connected device. For example $2:ALL will translate to all ports on slot 2.</li>
</ul>
</div>



<div class="section" id="Attribute variables">
<h2>Attribute variables</h2>
<p>ACLI's attribute variables are read-only variables which make available in ACLI the underlying Control::CLI::Extreme Perl module attributes. <a href=http://search.cpan.org/~lstevens/Control-CLI-Extreme-1.00/lib/Control/CLI/Extreme.pm#Main_I/O_Object_Methods>http://search.cpan.org/~lstevens/Control-CLI-Extreme-1.00/lib/Control/CLI/Extreme.pm#Main_I/O_Object_Methods</a> see: <i>'attribute() - Return device attribute value'</i></p>
<p>Attribute variables always commence with '$_' followed by the attribute name. All the available attribute variables can be easily dumped with the embedded <i>'@vars atribute'</i> command.</p>
<pre>
	VSP-8284XSQ:1#% @vars attribute
	
	$_family_type          = PassportERS
	$_is_nncli             = 1
	$_is_acli              = 1
	$_model                = VSP-8284-XSQ
	$_sw_version           = 8.0.0.0
	$_fw_version           = 8.0.0.0
	$_slots                = 1,2
	$_ports                = ,ARRAY(0x411e43c),ARRAY(0x41238e4)
	$_sysname              = VSP-8284XSQ
	$_base_mac             = 00-51-00-3f-a8-00
	$_baudrate             =
	$_max_baud             = 115200
	$_is_voss              = 1
	$_is_apls              = 0
	$_apls_box_type        =
	$_brand_name           = Extreme Networks
	$_is_master_cpu        = 1
	$_is_dual_cpu          = 0
	$_cpu_slot             = 1
	$_is_ha                =
	$_stp_mode             = mstp
	$_oob_ip               = 192.168.56.80
	$_oob_virt_ip          =
	$_oob_standby_ip       =
	$_is_oob_connected     = 1
	
	VSP-8284XSQ:1#%
</pre>
<p>The above command might require a small delay to complete. This has to do with how Control::CLI::Extreme handles the attributes; some are discovered & set during connection, others are set on demand, the first time a query is made for the attribute (in this case the modules executes switch CLI commands against the switch to obtain the data; these commands will not be visible on the ACLI interface). Though once an attribute has been fetched, it is cached and quickly retrievable on subsequent requests.</p>
<p>To view the <i>$_ports</i> arrays, simply provide the relevant slot number (from <i>$_slots</i>) in [] brackets:</p>
<pre>
	VSP-8284XSQ:1(config)#% $_ports[1]
	
	$_ports[1]  = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42
	
	VSP-8284XSQ:1(config)#% $_ports[2]
	
	$_ports[2]  = 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42
	
	VSP-8284XSQ:1(config)#%
</pre>
</div>



<div class="section" id="Viewing variables">
<h2>Viewing variables</h2>
<p>Variables of any type, user defined, reserved and attribute variables can be viewed by simply typing the variable on the ACLI session.</p>
<pre>
	VSP-8284XSQ:1#% $myvar
	
	$myvar      = 1/1,1/5
	
	VSP-8284XSQ:1#% $$
	
	$$          = VSP-8284XSQ
	
	VSP-8284XSQ:1#% $_sysname
	
	$_sysname   = VSP-8284XSQ
	
	VSP-8284XSQ:1#%
</pre>
<p>User defined variables can also be dumped via the embedded <i>'@vars show'</i> or <i>'@vars raw'</i> commands. The former can also be abbreviated as just <i>'@vars'</i> or even just <i>'@$'</i> and the latter as <i>'@$ raw'</i>.</p>
<pre>
	VSP-8284XSQ:1#% @vars show
	
	$_            = 10
	$allPorts     = 1/1-1/42,2/1-2/42
	$hash{}       = (name=>string; new=>99; numbers=>1-20; ports=>2/1-2/5)
	$i            = 4
	$ifdx[]       = (232; 236; 296; 300)
	$ifdxPort{}   = (232=>1/41; 236=>1/42; 296=>2/41; 300=>2/42)
	$input        = 42
	$isidPorts{}  = (666666=>1/11,1/13-1/15,1/17,1/19-1/21,1/23; 777777=>1/10-1/15,1/25)
	$key          = 2/42
	$list[]       = (1/1-1/10; 1-3; newstring; 99)
	$myvar        = 1/1,1/5
	$port[]       = (1/41; 1/42; 2/41; 2/42)
	$portIfdx{}   = (1/41=>232; 1/42=>236; 2/41=>296; 2/42=>300)
	$portMac{}    = (1/41=>00:51:00:3f:a8:28; 1/42=>00:51:00:3f:a8:2c; 2/41=>00:51:00:3f:a8:68; 2/42=>00:51:00:3f:a8:6c)
	$portRange    = 1/1-1/10
	$range        = 1-10
	
	Unsaved variables exist
	
	VSP-8284XSQ:1#% @$
	
	$_            = 10
	$allPorts     = 1/1-1/42,2/1-2/42
	$hash{}       = (name=>string; new=>99; numbers=>1-20; ports=>2/1-2/5)
	$i            = 4
	$ifdx[]       = (232; 236; 296; 300)
	$ifdxPort{}   = (232=>1/41; 236=>1/42; 296=>2/41; 300=>2/42)
	$input        = 42
	$isidPorts{}  = (666666=>1/11,1/13-1/15,1/17,1/19-1/21,1/23; 777777=>1/10-1/15,1/25)
	$key          = 2/42
	$list[]       = (1/1-1/10; 1-3; newstring; 99)
	$myvar        = 1/1,1/5
	$port[]       = (1/41; 1/42; 2/41; 2/42)
	$portIfdx{}   = (1/41=>232; 1/42=>236; 2/41=>296; 2/42=>300)
	$portMac{}    = (1/41=>00:51:00:3f:a8:28; 1/42=>00:51:00:3f:a8:2c; 2/41=>00:51:00:3f:a8:68; 2/42=>00:51:00:3f:a8:6c)
	$portRange    = 1/1-1/10
	$range        = 1-10
	
	Unsaved variables exist
	
	VSP-8284XSQ:1#%
</pre>
<p>If some variables have unsaved values, a message is displayed indicating so. See <i>"Saving device related ACLI settings"</i> section covering the <i>'@save'</i> embedded command.</p>
<p>The same <i>'@vars'</i> command also accepts wildcards to only display a subset or individual variable.</p>
<pre>
	VSP-8284XSQ:1#% @vars show $input
	
	$input      = 42
	
	VSP-8284XSQ:1#% @vars show ange
	
	$portRange  = 1/1-1/10
	$range      = 1-10
	
	VSP-8284XSQ:1#%
</pre>
<p>Whereas to dump all attribute variables use the <i>'@vars attribute'</i> command, which also accepts wildcards.</p>
<pre>
	VSP-8284XSQ:1#% @vars attribute ip
	
	$_oob_ip               = 192.168.56.71
	$_oob_virt_ip          =
	$_oob_standby_ip       =
	
	VSP-8284XSQ:1#%
</pre>
</div>



<div class="section" id="Dereferencing variables in CLI commands">
<h2>Dereferencing variables in CLI commands</h2>
<p>Once a variable has been set it can be used in any ACLI command (CLI commands, alias arguments, etc..) and they technically can even be used as commands themselves (instead of aliases) but this is not their prime purpose.</p>
<p>Variables will be dereferenced if enclosed in double quotes or curly brackets '{}'. Variables are not dereferenced if enclosed in single quotes.</p>
<p>To dereference a variable in a CLI command simply place the variable where it is needed.</p>
<pre>
	VSP-8284XSQ:1#% show interfaces gigabitEthernet interface $myvar
	          vars% show interfaces gigabitEthernet interface 1/1,1/5
	==========================================================================================
	                                      Port Interface
	==========================================================================================
	PORT                            LINK  PORT           PHYSICAL          STATUS
	NUM      INDEX DESCRIPTION      TRAP  LOCK     MTU   ADDRESS           ADMIN  OPERATE
	------------------------------------------------------------------------------------------
	1/1      192   10GbNone         true  false    1950  00:51:00:ca:e0:00 down   down
	1/5      196   10GbNone         true  false    1950  00:51:00:ca:e0:04 down   down
	
	VSP-8284XSQ:1#% if $myvar
	          vars% if 1/1,1/5
	         alias% show interfaces gigabitEthernet interface 1/1,1/5!!locked
	==========================================================================================
	                                      Port Interface
	==========================================================================================
	PORT                            LINK  PORT           PHYSICAL          STATUS
	NUM      INDEX DESCRIPTION      TRAP  LOCK     MTU   ADDRESS           ADMIN  OPERATE
	------------------------------------------------------------------------------------------
	1/1      192   10GbNone         true  false    1950  00:51:00:ca:e0:00 down   down
	1/5      196   10GbNone         true  false    1950  00:51:00:ca:e0:04 down   down
	VSP-8284XSQ:1#%
</pre>
<p>If variable echoing is enabled, a line is added after the comand entered showing the variable substitution. Variable echoing is by default enabled but can be disabled using the <i>'@vars echo'</i> embedded command or the <i>'vars echo'</i> command under ACLI control interface.</p>
<p>If the variable is separated by spaces or non alphanumeric characters, the above will work fine. If instead the variable needs to be dereferenced right up against some other alphanumeric text then the variable will need to be enclosed in curly brackets '{}', as in the example below.</p>
<pre>
	; $byte = Byte value to use in Nick-name + BMAC

	router isis
	   manual-area 49.0000
	   spbm 1
	   spbm 1 b-vid 4051-4052 primary 4051
	   spbm 1 nick-name 0.00.$byte
	   system-id 00bb.0000.{$byte}00
	exit
</pre>
<p>In the example above, if $byte was not enclosed in curlies, ACLI would try and look for a variable named $byte00, which would not exist. Use of curlies '{}' is actually embedding Perl code. See <i>"Eval of Perl in CLI commands"</i> section.</p>

<p>There is no difference between dereferincing an existing variable in user interactive use and in ACLI scripting mode. However, if trying to dereference a variable which is not set (i.e. does not exist) then the behaviour is different depending on whether ACLI is running in scripting mode or not.</p>
<p>In user interactive mode, an error is shown because the variable is not set; the variable is thus not replaced and the command is sent as is to the switch, which will also complain:</p>
<pre>
	VSP-8284XSQ:1#% show mlt $nosuchvar
	          vars% &lt;variable $nosuchvar is undefined&gt;
	          vars% show mlt $nosuchvar
	                         ^
	% Invalid input detected at '^' marker.
	VSP-8284XSQ:1#%
</pre>
<p>To demonstrate scripting mode, we shall copy-paste the following simple script:</p>
<pre>
	@if $nosuchvar
	   show mlt $nosuchvar
	@else
	   show mlt $nosuchvar
	@endif
</pre>
<p>Which gives the following:</p>
<pre>
	VSP-8284XSQ:1#%  @if $nosuchvar
	          vars% &lt;variable $nosuchvar is undefined&gt;
	VSP-8284XSQ:1#%  @else
	VSP-8284XSQ:1#%     show mlt $nosuchvar
	          vars% &lt;variable $nosuchvar is undefined&gt;
	          vars%     show mlt ''
	                             ^
	% Invalid input detected at '^' marker.
	VSP-8284XSQ:1#%
</pre>
<p>We still get an error indicating that the variable is not set. However in scripting mode undefined variables will always be dereferenced as the empty string ''. This is because, if used in ACLI's scripting conditional operators (@if, @while, @until, etc..) the undefined variable will need to be handed off to Perl for evaluation and it needs to be seen by Perl as an empty string (else the Perl eval would fail). Also in scripting mode, use of an undefined variable will result in script execution to stop, as seen above (the last @endif statement never executes).</p>
</div>



<div class="section" id="Using variables in scripts">
<h2>Using variables in scripts</h2>
<p>As we have seen, all the variables types can be used in CLI commands, either by directly embedding them in CLI commands or via the embedded Perl code snippets using curly brackets '{}'.</p>
<p>In ACLI scripting mode, all variables can also be used in ACLI's conditional operators, which are covered in the scripting section. A quick list of these operators follows.</p>
<pre>
	@if &lt;cond&gt;, @elsif &lt;cond&gt;, @else, @endif            if / elsif / else conditional operators
	@while &lt;cond&gt;, @endloop                             while loop construct
	@loop, @until &lt;cond&gt;                                loop until construct
	@for &lt;$var&gt; &&lt;start&gt;..&lt;end&gt;[:&lt;step&gt;], @endfor       for loop construct using range input
	@for &lt;$var&gt; &&lt;comma-separated-list&gt;, @endfor        for loop construct using list input
	@next [if &lt;cond&gt;]                                   jump to next value in a for loop construct
	@last [if &lt;cond&gt;]                                   break out of a while, until or for loop construct
	@exit [if &lt;cond&gt;]                                   break out of sourced script
</pre>
<p>Variables can be used wherever the <i>'&lt;cond&gt;'</i> field is seen as well as after the '&' character in the <i>'@for'</i> loop operator. The conditions been matched with the variables do not need to be enclosed in any curly brackets here. The <i>'&lt;cond&gt;'</i> condition matches are also eval-ed as Perl code, so parenthesis can of course be used if needed depending on use of logical operators. See the scripting section.</p>
<p>When running scripts it can be necessary to use a number of different variables to make the script function. Once the script has terminated these variables will remain visible in the <i>@vars show</i> commands and will in some way pollute any variables which may have been set for interactive use of the CLI. To prevent script variables from polluting the other non-script variables there are two possibilities.</p>
<p>Either insert the following embedded command at the very end of the script:</p>
<pre>
	@vars clear script
</pre>
<p>Any variable which was brought into existence during execution of a script will have an internal marker; the above command will thus delete all these variables. The problem with this approach is that the script could terminate before reaching the end, the above command does not get executed and the script variables remain. Of course the above command can be executed by the user.</p>
<p>The other, and more recent, approach is to declare the variables withing the script using the <i>@my</i> command. There are three possible forms:</p>
<pre>
	@my $var = 1/1
	@my $var1, $var2, $h{}, $l[]
	@my $prfx_*
</pre>
<p>The first form declares one variable and at the same time initializes that variable with a value. The second form can declare a comma separated list of variables, but these cannot be initialized to a value in this form. The third and last form declares that any variable starting with <i>$prfx_</i> will be treated as internal to the script. Hence if we were writing a script called init.run, we could include a declaration of:</p>
<pre>
	@my $init_*
</pre>
<p>And then within the script if we spawn variables such as <i>$init_var1, $init_var2, $init_list[], $init_hash{}</i> these will automatically be considered script variables and will not be visisble in the <i>@vars show</i> command.</p>
</div>



<div class="section" id="Dictionary variables">
<h2>Dictionary variables</h2>
<p>The ACLI dictionary functionality also makes use of variables and these are marked so as to be kept separate from user variables. These can be viewed with <i>@vars show dictionary</i>. See the <i>"Dictionaries"</i> section for more information.</p>


<div class="section" id="Storing variables">
<h2>Storing variables</h2>
<p>User defined variables can be saved against the MAC address of the device to which the ACLI session is connected to. This is useful for automatically restoring all the same variables when re-connecting via ACLI to the same device again. To save the variables use either the <i>'@save all'</i> or <i>'@save vars'</i> embedded commands. See also <i>"Saving device related ACLI settings"</i> section.</p>
</div>

</BODY>
</HTML>
