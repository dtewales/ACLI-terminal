package Encoder;
my $Version = "0.05";

# VOSS config to json (c2j) encoder
# Ensure that j2c decoder is of same major version to ensure operating on same data schema

=ignore

################################################################################
#                                    SYNTAX                                    #
################################################################################
# Special directives:
#	SCHEMA_BEGIN			: Marks beginning of schema
#	SCHEMA_END			: Marks end of schema; all lines between SCHEMA_BEGIN and SCHEMA_END are treated like comments
# 	COMMENT_LINE = "<char>"		: Set the character which if seen at beginning of device config line makes the line a comment
#					  This is needed to skip comment lines when parsing a config
#	PORT_ALL = 1-<X>		: This sets what the highest number of expected ports is on a given slot, and is used to generate
#					  a port list when the device lists ports a <slot>/ALL, as BOSS does. If not set, 99 is assumed.
#	CLEAR_PERSIST_CONTEXT = "<cmd>" : Command which indicates exiting a configuration context, used to forget last persistent variable
#	DEFAULTS			: In the following lines provide space or tab indented json initialization values
#
# Then simply provide exhaustive list of lines expected to be found in config file, each line followed with the desired json encoding of data
# extracted from that line. Arguments withing the config line can be encoded as <arg>. The json encoding lines which follow must be space or
# tab indented. Or the first json line must begin with '{' and the last line must end with '}'.
# All json encodings supported. Hash of hashes, array of hashes and hashes of arrays...
#
# Example1 (pretty - no outer curlies):
# vlan create <vid> name <name type port <inst>
#	vlan: {
#		<vid>: {
#			name: <name>
#			instance: <inst>
#		}
#	}
#
# Example2 (pretty - with outer curlies):
# vlan create <vid> name <name type port <inst>
# {
#	vlan: {
#		<vid>: {
#			name: <name>
#			instance: <inst>
#		}
#	}
# }
#
# Example3 (compact):
# vlan create <vid> name <name type port <inst>
#	vlan: {	<vid>: { name: <name>, instance: <inst> } }
#
# Example4 (using array list with square brackets):
# ip name-server <ip>
#	dns: { server: [<ip>] }
#
# The json syntax is forgiving in that commas don't need to placed at end of lines.
# If the json syntax is found to be invalid an error will detail the line and why.
# If in doubt refer to JSON syntax.
# Make sure the schema is sensible; for example if the VLAN-id is used as the sub-key for the 'vlan' key, make sure that only VLAN-ids are used as
# sub-keys for the 'vlan' key. 
#
# Arguments <arg> syntax inside command line:
#	<name>			: Argument variable which will accepts any string
#	<name:1-10>		: Argument variable which will accept a number between 1 and 10
#	<name:1-10,>		: Argument variable which will accept a list and/or range of numbers where all numbers must be between 1 and 10
#	<name:value1,value2,etc>: Argument variable which will accept only discrete values: "value1" or "value2" or ect..
#	<name:*>		: Argument variable which will glob the rest of the command line
#	<port>			: When name = 'port', the argument variable only accepts a single valid port for the connected host (or in the defined input port range)
#	<ports>			: When name = 'ports', the argument variable accepts a list and/or range of valid ports for the connected host (or in the defined input port range)
#	<ip>			: When name = 'ip', the argument only accepts an IPv4 address
#	<ipv6>			: When name = 'ipv6', the argument only accepts an IPv6 address
#	<ip:mask>		: Accepts an IPv4/masklen address; can use <ip> for ip address, <mask> dotted mask, <masklen> mask bits 
#	<ipv6:mask>		: Accepts an IPv6/masklen address; can use <ip> for ip address, <mask> mask bits 
#
# Arguments <arg> syntax inside json lines:
# 	<var:%>			: true if set else false 
# 	<var:!%>		: false if set else true 
#	<var:abc=1,def=xyz,...>	: Mapping of argument values; e.g. if argument <var> has value 'abc' then encode in json as 1; etc..
#
# You can also reference data already in the data structure using the same json var syntax as in the decode.j2c file:
#	$<key1>{key2}[idx1]{key3}
#
# If an argument is a list of values, and the <arg> is used either as a json key [not array list], then as many keys will be expanded in the json encoding.
#
# For example this definition:
#
# vlan create <vids> type port <inst>
#	vlan: {	<vids>: { instance: <inst> } }
#
# When used to encode this config line: vlan create 1-3,5 type port 1
# Will result in this json encoding:
#	vlan: {
#		1: {
#			instance: 1
#		},
#		2: {
#			instance: 1
#		},
#		3: {
#			instance: 1
#		},
#		5: {
#			instance: 1
#		},
#	}
#
#
# Arguments <arg> hold their values only while processing the current config line. But it is also possible to hold argument values persistently.
# This is done by inserting a "!" like <!arg>. For example, if we wanted to json encode these lines:
#
# interface vlan 200
# ip address 10.0.200.1 255.255.255.0 1
# exit
#
# And assume that we wanted to store the IP/mask under the vlan key. This can be achieved with these definitions:
#
# interface vlan <!vid>
# ip address <ip> <mask> [<macoffset>]
# 	vlan: { <vid>: { ip: <ip>, mask: <mask> } }
# exit
#
# In practice the argument values are held in 2 separate tables, one persistent and one not.
# When a lookup is performed in the json encoding, first a lookup is performed in the non-persistent table, and if no value is found there, then a lookup
# is performed in the persistent table.
#
# Some configuration, using identical CLI commands, can apply to different contexts, for example global context or VLAN or Port or MLT context.
# In order to encode the config in the correct context, the definitions can require that a variable be set in the persistent table and also that that
# variable was the most recent variable set in the persistent table. For example:
#
# interface mlt 62
# isis enable
# exit
#
# -and-
#
# interface gigabitEthernet 1/2
# isis enable
# exit
#
# The "isis enable" command is the same, yet it applies to different configuration contexts, which will need to be encoded as follows.
# 
# interface mlt <!mltid>
# isis enable !mltid
# 	mlt: { <mltid> : {isis: { enable: true } } }
# exit
#
# interface GigabitEthernet <!ports>
# isis enable !ports
#	port: { <ports>: {isis: { enable: true } } }
# exit
#
# Specifying either "!mltid" or "!ports" as the last keyword of the "isis enable" command, allows each to be encoded as a different command
# with a different encoding. When the "isis enable" is encountered, the most recently set variable in the persistent table will determine which
# is used to encode the command.
#
# The very same problem, but using an example between port context and global context.
#
# lacp enable
#
# -and-
#
# interface GigabitEthernet 1/3
# lacp enable
# exit
#
# This time the "lacp enable" command applies to the global context as well as to port context. To differentiate between the two we can use use
# these definitions.
#
# lacp enable !
# 	lacp: { enable: true }
#
# interface GigabitEthernet <!ports>
# lacp enable !ports
# 	port: { <ports>: { lacp: { enable: true } } }
# exit
#
# By specifying the single "!" after that "lacp enable" command, we are making sure that the definition will only apply when no persistent
# variable is set. Normally global commands precede interface context config commands, but what would happen if that was not the case ?
# In order to clear the last persistent variable name, the following directive can be specified:
#
# CLEAR_PERSIST_CONTEXT = "exit"
#
# Now when the "exit" command is seen, the last stored persistent variable is cleared.
#
#
# If we wanted to encode data into a different part of the schema, we can back reference data already in the structure.
# For example, if we encoded these lines:
# interface vlan 190
# ip address 10.120.200.1 255.255.248.0 4
# [...later in same config...]
# ip dhcp-relay fwd-path 10.120.200.1 164.166.4.18 
# ip dhcp-relay fwd-path 10.120.200.1 164.166.4.18 mode dhcp
#
# We can use this encoding:
#
# interface vlan <!vid>
# ip address <ip> <mask> <macoffset:0-999>
#	vlan: { <vid>: { ip: <ip>, mask: <mask> } }
#	ip: { interface: { <ip>: { mask: <mask>, vlan: <vid> } } }
# exit
# ip dhcp-relay fwd-path <ip> <srv> [mode <mode>]
#	vlan: { $ip{interface}{<ip>}{vlan}: { dhcp-relay: { server: <srv>, mode: <mode> } } }
#
# Notice the use above of $ip{interface}{<ip>}{vlan}, which harks back to the data structure to retrieve the vlan-id for the IP address.
# This is handy if we want the vlan dhcp-relay info to be stored under the corresponding vlan key
#
#
# Best to avoid assigning key and value directly as this:
#
# banner <n> <line>
# 	system: { banner: { custom: { <n>: <line> } } }
#
# Because in the j2c file, variable $system{banner}{custom}{x} will only refer to the keys, not the values; one will have to use the more cryptic
# $system{banner}{custom}{x:v} to get to the values
#
# If possible, it is better to use a sub-hash like this:
#
# banner <n> <line>
#	system: { banner: { custom: { <n>: {line: <line> } } } }
#
# So that in j2c file the keys can be expressed as $system{banner}{custom}{x} and the values as $system{banner}{custom}{x}{line}
#
#
# Config lines which present no useful data to extract, can be included without any json encoding on following lines.
# This will ensure those lines do not throw errors when parsed. These lines can also set persistent <!arg> arguments.
#
#
################################################################################
#                                    SCHEMA                                    #
################################################################################
SCHEMA_BEGIN	# Schema is not actually read in by rosetta.pl

	Omitted, can be obtained with: rosetta.pl schema <this-file.c2j> [<out-schema-file>]

SCHEMA_END	# Only lines after this one will actially be read in 


################################################################################
#                                  DEFINITIONS                                 #
################################################################################

COMMENT_LINE = "#"
CLEAR_PERSIST_CONTEXT = "exit"
DEFAULTS
	system: { autosave: false }
	system: { banner: true }
	system: { vlan: { auto-pvid: true } }
	system: { flags: {
		hsecure: false
		block-snmp: false
		dvr-leaf: false
		enhancedsecure-mode: false
		ipv6-egress-filter: false
		ipv6-mode: false
		flow-control-mode: false
		logging: true
		nni-mstp: false
		syslog-rfc5424-format: true
		spbm-config-mode: true
		urpf-mode: false
		verify-config: true
		vrf-scaling: true
	} }
	tftp: { hash: false }
	sonmp: { enable: true }
	dhcp-relay: {enable: true}
	ip: { routing: true }
	mgmt: { vlan: { vlan-id: 4048 } }
	vlan: { 4048: { mgmt: true } }
	mgmt-access-control: { by-mac: { default-action: allow } }
	spanning-tree: { mode: mstp }

# Lines where we extract no json:
enable
configure terminal
interface GigabitEthernet <!ports>
interface vlan <!vid>
router <!rtr:ospf,rip,isis,vrrp,bgp>
router vrf <!vrf>
exit
end


# BOOT CONFIGURATION
boot config flags hsecure
	system: { flags: { hsecure: true } }
boot config flags block-snmp
	system: { flags: { block-snmp: true } }
boot config flags dvr-leaf-mode
	system: { flags: { dvr-leaf: true } }
boot config flags enhancedsecure-mode [<mode:jitc,non-jitc>]
	system: { flags: { enhancedsecure-mode: { enable: true, mode: <mode> } } }
boot config flags ftpd
	ftp: { enable: true }
boot config flags ipv6-egress-filter
	system: { flags: { ipv6-egress-filter: true } }
boot config flags ipv6-mode
	system: { flags: { ipv6-mode: true } }
boot config flags flow-control-mode
	system: { flags: { flow-control-mode: true } }
no boot config flags logging
	system: { flags: { logging: false } }
boot config flags nni-mstp
	system: { flags: { nni-mstp: true } }
no boot config flags syslog-rfc5424-format
	system: { flags: { syslog-rfc5424-format: false } }
boot config flags spanning-tree-mode <mode>
	spanning-tree: { mode: <mode> }
no boot config flags spbm-config-mode
	system: { flags: { spbm-config-mode: false } }
boot config flags sshd
	ssh: { enable: true }
boot config flags telnetd
	telnet: { enable: true }
boot config flags tftpd
	tftp: { enable: true }
boot config flags urpf-mode
	system: { flags: { urpf-mode: true } }
no boot config flags verify-config
	system: { flags: { verify-config: false } }
boot config flags vrf-scaling
	system: { flags: { vrf-scaling: true } }
boot config logfile <minkb> <maxsize> <percentfree>
	logging: { min-free-space: <minkb>, max-log-file-size: <maxsize>, percent-free-space: <percentfree>}
boot config host tftp-hash
	tftp: { hash: true }
boot config host tftp-rexmit <times>
	tftp: { retransmit: <times> }
boot config host tftp-timeout <timeout>
	tftp: { timeout: <timeout> }
boot config host user <user>
	ftp: { username: <user> }

# SPBM CONFIGURATION
spbm
	spbm :{ enable: true }
spbm ethertype <etype>
	spbm: { ethertype: <etype> }
spbm nick-name server range <atof>
	spbm :{ nickname-server: { prefix: <atof>.00.00 } }
spbm nick-name server prefix <prefix>
	spbm :{ nickname-server: { prefix: <prefix> } }
spbm nick-name server
	spbm :{ nickname-server: { enable: true } }

# CLI CONFIGURATION
telnet-access sessions <sessions>
	telnet: { sessions: <sessions> }
max-logins <logins>
	cli: { max-logins: <logins> }
cli timeout <time>
	cli: { inactive-timeout: <time>}
prompt <sysname>
	system: { name: <sysname> }
banner custom
	system: { banner: { enable: true, type: custom } }
banner <line>
	system: { banner: { custom: [<line>] } }
banner motd <line>
	system: { banner: { motd: [<line>] } }
passwordprompt <prompt>
	password: { prompt: <prompt> }
password aging-time day <days>
	password: {security: { aging-time: <days> } }
password min-passwd-len <len>
	password: {security: { min-passwd-len: <len> } }
password password-history <hist>
	password: {security: { history: <hist> } }
clilog enable
	cli: { logging: { enable: true } }
snmplog enable
	snmp: { logging: { enable: true } }
auto-recover-delay <delay>
	system: { auto-recover-delay: <delay> }

# CLOCK TIME-ZONE CONFIGURATION
clock time-zone <continent> <city> [<subarea>]
	system: { clock: { time-zone: { continent: <continent>, city: <city>, subarea: <subarea> } } }

# SYSTEM CONFIGURATION
ip domain-name <name>
	dns: { domain-name: <name> }
ip name-server primary <ip>
	dns: { server: [<ip>] }
ip name-server secondary <ip>
	dns: { server: [<ip>] }
ip name-server tertiary <ip>
	dns: { server: [<ip>] }
portlock enable
	system: { port-lock: true }
sys mtu <mtu>
	system: { mtu: <mtu> }
sys msg-control [action <action:both,send-trap,suppress-msg>] [control-interval <int>] [max-msg-num <num>]
	logging: { message-control: {
		action: <action>
		control-interval: <int>
		max-msg-num: <num>
	} }
sys msg-control
	logging: { message-control: { enable: true } }
sys force-topology-ip-flag
syslog max-hosts <hosts>
	syslog: { max-hosts: <hosts> }
syslog host <n>
syslog host <n> address <ip>
	syslog: { <n>: { server: <ip> } }
syslog host <n> facility <facility>
	syslog: { <n>: { facility: <facility> } }
syslog host <n> secure-forwarding mode <mode:none,tls>
	syslog: { <n>: { secure-forwarding: { mode: <mode> } } }
syslog host <n> udp-port <udpport>
	syslog: { <n>: { udp-port: <udpport> } }
syslog host <n> mapinfo <level>
	syslog: { <n>: { map: { info: <level> } } }
syslog host <n> mapwarning <level>
	syslog: { <n>: { map: { warning: <level> } } }
syslog host <n> maperror <level>
	syslog: { <n>: { map: { error: <level> } } }
syslog host <n> mapfatal <level>
	syslog: { <n>: { map: { fatal: <level> } } }
syslog host <n> severity <level> [<rest:*>]
	syslog: { <n>: { level: <level> } }
syslog host <n> secure-forwarding tcp-port <tcpport>
	syslog: { <n>: { secure-forwarding: { tcp-port: <tcpport> } } }
syslog host <n> enable
	syslog: { <n>: { enable: true } }
syslog enable
	syslog: { enable: true }

# LOG CONFIGURATION
logging level <level:0-4>
	logging: { level: <level> }
logging transferFile <id> address <ip>
	logging: { transfer: {<id>: { address: <ip> } } }
logging transferFile <id> filename-prefix <prefix>
	logging: { transfer: {<id>: { filename-prefix: <prefix> } } }

# LINK-FLAP-DETECT CONFIGURATION
link-flap-detect auto-port-down
	link-flap: { auto-port-down: true }
link-flap-detect frequency <freq>
	link-flap: { frequency: <freq> }
link-flap-detect interval <interval>
	link-flap: { interval: <interval> }
link-flap-detect send-trap
	link-flap: { trap: true }

# IEEE VLAN AGING CONFIGURATION

# ACCESS-POLICY CONFIGURATION
access-policy
	mgmt-access-control: { enable : true }
access-policy <n>
access-policy <n> enable
	mgmt-access-control: { rule: { <n>: { enable : true } } }
access-policy <n> mode <mode:allow,deny>
	mgmt-access-control: { rule: { <n>: { mode : <mode> } } }
access-policy <n> [name <name>] [precedence <precedence>] [network <ip> <mask>] [accesslevel <level:ro,rw,rwa>]
	mgmt-access-control: { rule: { <n>: {
		name: <name>
		precedence: <precedence>
		network: <ip>
		mask: <mask>
		access-level: <level>
	} } }
access-policy <n> access-strict
	mgmt-access-control: { rule: { <n>: { access-strict : true } } }
access-policy <n> [<http:http>] [<ssh:ssh>] [<telnet:telnet>] [<ftp:ftp>] [<snmpv3:snmpv3>] [<tftp:tftp>]
	mgmt-access-control: { rule: { <n>: {
		http: <http:%>
		ssh: <ssh:%>
		telnet: <telnet:%>
		ftp: <ftp:%>
		snmpv3: <snmpv3:%>
		tftp: <tftp:%>
	} } }
access-policy <n> snmp-group <group-name> <model:usm,snmpv1,snmpv2c>
	mgmt-access-control: { rule: { <n>: { snmp-group: { <group-name>: { model: <model> } } } } }
access-policy by-mac action <action:allow,deny>
	mgmt-access-control: { by-mac: { default-action: <action> } }
access-policy by-mac <mac> <action:allow,deny>
	mgmt-access-control: { by-mac: { mac: { <mac>: { action: <action> } } } }


# SSH CONFIGURATION


ssh max-sessions <sessions>
	ssh: { max-sessions: <sessions> }
ssh port <tcpport>
	ssh: { tcp-port: <tcpport> }
ssh timeout <timeout>
	ssh: { timeout: <timeout> }
ssh version v2only
no ssh dsa-auth
	ssh: { dsa-auth: false }
no ssh pass-auth
	ssh: { pass-auth: false }
no ssh rsa-auth
	ssh: { rsa-auth: false }
no ssh keyboard-interactive-auth
	ssh: { keyboard-interactive: false }
no ssh x509v3-auth enable
	ssh: { x509v3: { enable: false } }
ssh x509v3-auth username overwrite
	ssh: { x509v3: { username: { overwrite: true } } }
ssh x509v3-auth username strip-domain
	ssh: { x509v3: { username: { strip-domain: true } } }
ssh x509v3-auth username use-domain
	ssh: { x509v3: { username: { use-domain: true } } }
ssh x509v3-auth revocation-check-method <meth:ocsp,none>
	ssh: { x509v3: { revocation: <meth> } }
ssh sftp enable
	ssh: { sftp: { enable: true } }
ssh
	ssh: { enable: true }
no ssh client enable
	ssh: { client: { enable: false } }

# MCAST SOFTWARE FORWARDING CONFIGURATION
multicast software-forwarding
	ip: { multicast: { software-forwarding: true } }

# SNMP V3 GLOBAL CONFIGURATION
snmp-server contact <contact>
	system: { contact: <contact> }
snmp-server location <location>
	system:{ location: <location> }
snmp-server authentication-trap enable
	snmp: { notification-control: { authentication-trap: { enable : true } } }

# SNMP V3 GROUP MEMBERSHIP CONFIGURATION
snmp-server user <user> group <group>
	snmp: { user: { <user>: {
		group: <group>
	}}}

# SNMP V3 NOTIFY FILTER CONFIGURATION

# SNMP V3 MIB VIEW CONFIGURATION
snmp-server view <name> <oid> 
	snmp: { mib-view: { <name>: { subtree: <oid> } } }

# SNMP V3 GROUP CONFIGURATION
snmp-server group <group> <context> [<seclev:auth-no-priv,auth-priv,no-auth-no-priv>] [read-view <rdview>] [write-view <rwview>] [notify-view <nfview>]
	snmp: { group: {
		context: <context>
		security-level: <seclev>
		read-view: <rdview>
		write-view: <rwview>
		notify-view: <nfview>
	} }

# SNMP V3 TARGET ADDRESS CONFIGURATION
snmp-server host <host> [port <udpport>] <version:v1,v2c,v3> <seclev:noAuthNoPriv,authNoPriv,authPriv> <user> [<inform:inform>]
	snmp: { host: {
		<host>: {
			port: <udpport>
			version: <version>
			user: <user>
			security-level: <seclev:noAuthNoPriv=no-auth-no-priv,authNoPriv=auth-no-priv,authPriv=auth-priv>
			trap: <inform:!%>
			inform: <inform:%>
		}
	}}

# DDI CONFIGURATION
pluggable-optical-module ddm-alarm-portdown
	pluggable: { ddm: { alarm-port-down: true } }
pluggable-optical-module ddm-monitor
	pluggable: { ddm: { monitor: { enable: true } } }
pluggable-optical-module ddm-monitor-interval <interval>
	pluggable: { ddm: { monitor: { interval: <interval> } } }
pluggable-optical-module ddm-traps-send
	pluggable: { ddm: { trap: enable } }

# SLOT CONFIGURATION

# MAC AGING CONFIGURATION
mac-address-table aging-time <secs>
	system: { vlan: { aging-time: <secs> } }

# SMTP CONFIGURATION
smtp server <server>
	smtp: { server: <email> }
smtp receiver-email add <email-list>
	smtp: { receiver-email: <email-list> }
smtp sender-email <email>
	smtp: { sender-email: <email> }
smtp domain-name <domain>
	smtp: { domain-name: <domain> }
smtp port <tcpport>
	smtp: { tcp-port: <tcpport> }
smtp status-send-timer <timer>
	smtp: { status-send-timer: <timer> }
smtp enable
	smtp: { enable: true }



# WEB CONFIGURATION
web-server password min-passwd-len <len>
	web: { password: { min-passwd-len: <len> } }
web-server tls-min-ver <ver:tlsv11,tlsv11,tlsv12>
	web: { tls-min-ver: <ver:tlsv10=1.0,tlsv11=1.1,tlsv12=1.2> }
web-server enable
	web: { http: true, https: true}
no web-server secure-only
	web: { http: false}
web-server read-only-user enable
	web: { read-only-user: true}
web-server [def-display-rows <rows>] [http-port <httpport>] [https-port <httpsport>] [inactivity-timeout <secs>]
	web: {
		display-rows: <rows>
		http-port: <httpport>
		https-port: <httpsport>
		inactivity-timeout: <secs>
	}

# GLOBAL FDB FILTER CONFIGURATION

# QOS CONFIGURATION - PHASE I

# LACP CONFIGURATION
vlacp enable !
	vlacp: { enable: true }
vlacp sequence-num
	vlacp: { sequence-num: true }
lacp [aggr-wait-time <agtime>] [system-priority <prio>] [fast-periodic-time <ftime>] [slow-periodic-time <stime>] [timeout-scale <scale>]
	lacp: {
		aggr-wait-time: <agtime>
		system-priority: <prio>
		fast-periodic-time: <ftime>
		slow-periodic-time: <stime>
		timeout-scale: <scale>
	}
lacp enable !
	lacp: { enable: true }

# VRF CONFIGURATION
ip vrf <name> vrfid <id>
	ip: { vrf: { <name>: { vrf-id: <id> } } }
ip vrf <name> max-routes <routes>
	ip: { vrf: { <name>: { ipv4: { max-routes: <routes> } } } }
ip vrf <name> ipv6-max-routes <routes>
	ip: { vrf: { <name>: { ipv6: { max-routes: <routes> } } } }
no ip vrf <name> max-routes-trap enable
	ip: { vrf: { <name>: { ipv4: { max-routes-trap: false } } } }
no ip vrf <name> ipv6-max-routes-trap enable
	ip: { vrf: { <name>: { ipv6: { max-routes-trap: false } } } }
no ip vrf <name> vrf-trap enable
	ip: { vrf: { <name>: { trap: false } } }

# MAINTENANCE-DOMAIN CONFIGURATION

# MAINTENANCE-ASSOCIATION CONFIGURATION

# MAINTENANCE-ENDPOINT CONFIGURATION

# POE GLOBAL CONFIGURATION
poe poe-power-usage-threshold <percent>
	poe: { power-usage-threshold: <percent>}
poe poe-pd-detect-type <type>
	poe: { pd-detect-type: <type>}
poe fast-poe-enable
	poe: { fast-poe: true}
poe perpetual-poe-enable
	poe: { perpetual-poe: true}

# PORT CHANNELIZE CONFIGURATION

# PORT CONFIGURATION - PHASE I
interface GigabitEthernet <!ports>
encapsulation dot1q
	port: { <ports> : { tagging: tagAll } }
spoof-detect enable
	port: { <ports> : { spoof-detect: true } }
private-vlan <type:isolated,promiscuous,trunk>
	port: { <ports> : { private-vlan: <type> } }
exit

# ISIS SPBM CONFIGURATION
router isis
spbm <id>
	isis: {spbm: {instance: <id> } }
spbm <id> nick-name <nick>
	isis: {spbm: {nick-name: <nick> } }
spbm <id> b-vid <vids> primary <vid>
	isis: {spbm: {
		bvids: <vids>
		primary-bvid: <vid>
	} }
spbm <id> multicast enable
	isis: {spbm: {multicast: true } }
spbm <id> ip enable
	isis: {spbm: {ip: true } }
spbm <id> ipv6 enable
	isis: {spbm: {ipv6: true } }
spbm <id> stp-multi-homing enable
	isis: {spbm: {stp-multi-homing: true } }
exit

# SPB-PIM-GW CONFIGURATION
router isis
spbm <id> multicast spb-pim-gw gateway enable
	isis: {spbm: {spb-pim-gw: { gateway: true } } }
spbm <id> multicast spb-pim-gw controller enable
	isis: {spbm: {spb-pim-gw: { controller: true } } }
exit

# MLT CONFIGURATION
mlt <mltid> enable name <name>
	mlt: {
		<mltid>: {
			name: <name>
			enable: true
		}
	}
mlt <mltid> member <ports>
	mlt: {
		<mltid>: {
			member: <ports>
		}
	}
	port: {
		<ports>: {
			mlt: <mltid>
		}
	}
mlt <mltid> encapsulation dot1q
	mlt: { <mltid> : { tagging: tagAll } }
mlt <mltid> private-vlan <type:isolated,promiscuous,trunk>
	mlt: { <mltid> : { private-vlan: <type> } }

# IP PREFIX LIST CONFIGURATION - GlobalRouter
ip prefix-list <name> <ipmask> id <id> ge <ge> le <le>
	ip: { prefix-list: { <name>: {
		network: <ipmask>
		id : <id>
		greater-equal: <ge>
		less-equal: <le>
	} } }

# IP PREFIX LIST CONFIGURATION - VRF
router vrf <!vrf>
ip prefix-list <name> <ipmask> id <id> ge <ge> le <le>
	ip: { vrf: { <vrf>: { prefix-list: { <name>: {
		network: <ipmask>
		id : <id>
		greater-equal: <ge>
		less-equal: <le>
	} } } } }
exit

# IPv6 PREFIX LIST CONFIGURATION - GlobalRouter

# IPv6 PREFIX LIST CONFIGURATION - VRF

# RMON CONFIGURATION
rmon
	rmon: { enable: true }
rmon util-method <meth:half,full>
	rmon: { util-method: <meth> }

# VLAN CONFIGURATION
vlan members remove 1 <ports> [portmember]
vlan create <vid> [name <name>] type port-mstprstp <isnt>
	vlan: {	<vid>: {
		name: <name>
		type: port
		instance: <inst>
	} }
vlan create <vid> [name <name>] type pvlan-mstprstp <inst> secondary <vid2>
	vlan: {	<vid>: {
		name: <name>
		type: pvlan
		instance: <inst>
		pvlan-second-bvid: <vid2>
	} }
vlan create <vid> [name <name>] type spbm-bvlan
	vlan: {	<vid>: {
		name: <name>
		type: spbm
		instance: 62
	} }
vlan members [add] <vid> <ports> portmember
	vlan: { <vid>: { ports-all: <ports> } }
vlan i-sid <vid> <isid>
	vlan: {<vid>: { i-sid: <isid> } }
	i-sid: {<isid>: { vlan: <vid> } }
interface vlan <!vid>
migrate-to-mgmt
dvr enable
	vlan: {<vid>: { dvr: { enable: true } } }
ip address <ip> <mask> <macoffset:0-999>
	vlan: { <vid>: { ip: <ip>, mask: <mask> } }
	ip: { interface: { <ip>: { mask: <mask>, vlan: <vid> } } }
ip arp-proxy enable
	vlan: { <vid>: { arp-proxy: true } }
ip directed-broadcast
	vlan: { <vid>: { directed-broadcast: true } }
ip rvs-path-chk
	vlan: { <vid>: { urpf: { enable: true } } }
	vlan: { <vid>: { urpf: { mode: exist-only } } }
ip rvs-path-chk mode <mode:exist-only,strict>
	vlan: { <vid>: { urpf: { mode: <mode> } } }
ip bfd
	vlan: {<vid>: { bfd: { enable: true } } }
nlb-mode <mode:multicast,unicast,igmp-mcast>
	vlan: {<vid>: { nlb: <mode> } }
ip spb-multicast enable
	vlan: { <vid>: { spb-multicast: true } }
ip spb-pim-gw enable
	vlan: { <vid>: { pim-gw: { enable: true } } }
interface vlan <!vid>
ip igmp last-member-query-interval 10 query-interval 125 query-max-response 100 robust-value 2
ip igmp [last-member-query-interval <lmqi>] [query-interval <qint>] [query-max-response <qmr>] [robust-value <robv>]
	vlan: { <vid>: { igmp: {
		last-member-query-interval: <lmqi>
		query-interval: <qint>
		query-max-response: <qmr>
		robust-value: <robv>
	} } }
ip igmp proxy
	vlan: { <vid>: { igmp: { proxy: true } } }
ip igmp router-alert
	vlan: { <vid>: { igmp: { router-alert: true } } }
ip igmp snooping
	vlan: { <vid>: { igmp: { snooping: true } } }
ip igmp upnp-filter [ip <ip:mask>]
	vlan: { <vid>: { upnp-filter: { 
		enable: true
		group: <addr>
		mask: <mask>
	} } }
ip igmp snoop-querier-addr <addr>
	vlan: { <vid>: { igmp: { snoop-querier: { address: <addr> } } } }
ip igmp snoop-querier
	vlan: { <vid>: { igmp: { snoop-querier: { enable: true } } } }
ip igmp version <vers>
	vlan: { <vid>: { igmp: { version: <vers> } } }
no ip igmp ssm-snoop
	vlan: { <vid>: { igmp: { ssm-snoop: true } } }
no ip igmp immediate-leave
	vlan: { <vid>: { igmp: { fast-leave: true } } }
ip dhcp-relay
	vlan: { <vid>: { dhcp-relay: { enable: true } } }
exit




# MSTP CONFIGURATION

# NLS CONFIGURATION
mgmt <!mgmt:oob,vlan,clip>
mgmt vlan <vid>
	mgmt: { vlan: { vlan-id: <vid> } }
mac-offset <offset>
mgmt clip vrf <vrf>
	mgmt: { clip: { vrf: <vrf> } }
ip address <ip:mask>
	mgmt: { <mgmt>: { ip: <ip>, mask: <mask> } }
ipv6 address <ipv6:mask>
	mgmt: { <mgmt>: { ipv6: <ipv6>, mask: <mask> } }
ip route <ip:mask> next-hop <nexthop> weight <weight>
	mgmt: { vlan: { route: [{
		route: <ip>
		mask: <mask>
		next-hop: <nexthop>
		weight: <weight>
	}] } }
enable
	mgmt: { <mgmt>: { enable: true } }
exit

# FHS CONFIGURATION

# MAC ACL CONFIGURATION

# IPv6 FHS ACL CONFIGURATION

# RA-GUARD CONFIGURATION

# DHCP-GUARD CONFIGURATION

# FHS SNOOPING CONFIGURATION

# SFLOW CONFIGURATION

# DHCP SNOOPING CONFIGURATION

# DHCP SNOOPING BINDING CONFIGURATION

# VIRTUAL IST CONFIGURATION

# MLT INTERFACE CONFIGURATION
interface mlt <!mltid>
smlt
	mlt: { <mltid> : { smlt: true } }
lacp enable key <key> [system-priority <priority>]
	mlt: { <mltid> : { lacp: { key: <key>, system-priority: <priority> } } }
flex-uni enable
	mlt: { <mltid> : { flex-uni: true } }
fa
	mlt: { <mltid> : { fabric-attach: { enable: false } } }
fa enable
	mlt: { <mltid> : { fabric-attach: { enable: true } } }
fa message-authentication [strict]
	mlt: { <mltid> : { fabric-attach: { message-authentication: { enable: true, key-mode: strict } } } }
no fa message-authentication
	mlt: { <mltid> : { fabric-attach: { message-authentication: { enable: false } } } }
fa management i-sid <isid> c-vid <cvid>
	mlt: { <mltid> : { fabric-attach: { management-vlan: { vlan-id: <cvid>, i-sid: <isid> } } } }
ip dhcp-snooping <mode:trusted,untrusted>
	mlt: { <mltid> : { dhcp-snooping: <mode> } }
ip arp-inspection <mode:trusted,untrusted>
	mlt: { <mltid> : { arp-inspection: <mode> } }
isis !mltid
	mlt: { <mltid> : {isis: {} } }
isis spbm <id> !mltid
	mlt: { <mltid> : {isis: { spbm: { instance: <id> } } } }
isis spbm <id> l1-metric <metric> !mltid
	mlt: { <mltid> : {isis: { spbm: { metric: <metric> } } } }
isis enable !mltid
	mlt: { <mltid> : {isis: { enable: true } } }
exit

# DVR CONFIGURATION
dvr leaf <domain>
	dvr: { mode: leaf, domain: <domain>}

# PORT CONFIGURATION - PHASE II
interface mgmtEthernet <!mgmt>
ip address <ip> <mask>
	mgmt: { <mgmt:mgmt=oob>: { ip: <ip>, mask: <mask> } }
exit

interface GigabitEthernet <!ports>
auto-sense enable
	port: { <ports>: { auto-sense: true } }
default-vlan-id 0
default-vlan-id <vid:1-4095>
	port: { <ports>: { pvid: <vid> } }
untag-port-default-vlan enable
	port: { <ports>: { tagging: unTagPvidOnly } }
rate-limit multicast <rate>
	port: { <ports>: { rate-limit: { multicast: <rate> } } }
rate-limit broadcast <rate>
	port: { <ports>: { rate-limit: { broadcast: <rate> } } }
name <name>
	port: { <ports>: { name: <name> } }
no shutdown
lacp key 10 aggregation enable priority 1 timeout-time short
lacp key <key> [aggregation <aggregation:enable>] [mode <mode:active,passive>] [priority <priority>] [timeout-time <timeout:short,long>] [timeout-scale <scale>]
	port: { <ports>: { lacp: {
		key: <key>
		aggregation: <aggregation%>
		enable: true
		passive: <mode:passive=true,active=false>
		priority: <priority>
		timeout-time: <timeout>
		timeout-scale: <scale>
	}}}
lacp enable !ports
 	port: { <ports>: { lacp: { enable: true } } }
spanning-tree mstp edge-port <edge:true,false>
	port: { <ports>: { spanning-tree: { mstp: { edge-port: <edge> } } } }
lldp cdp enable
	port: { <ports>: { cdp: true } }
spanning-tree bpduguard enable
	port: { <ports>: { bpdu-guard: true } }
qos 802.1p-override enable
	port: { <ports>: { qos: { l2trust: false } } }
access-diffserv enable
	port: { <ports>: { qos: { l3trust: false } } }
flex-uni enable
	port: { <ports>: { qos: { flex-uni: true } } }
isis
	port: { <ports>: {isis: {} } }
isis spbm <id>
	port: { <ports>: {isis: { spbm: { instance: <id> } } } }
isis spbm <id> l1-metric <metric>
	port: { <ports>: {isis: { spbm: { metric: <metric> } } } }
isis enable
	port: { <ports>: {isis: { enable: true } } }
vlacp [fast-periodic-time <fast-time>] [slow-periodic-time <slow-time>] [timeout <type:short,long>] [timeout-scale <scale>] [ethertype <etype>] [funcmac-addr <mac>]
	port: { <ports>: { vlacp: {
		fast-periodic-time: <fast-time>
		slow-periodic-time: <slow-time>
		timeout: <type>
		timeout-scale: <scale>
		ethertype: <etype>
		macaddress: <mac>
	} } }
vlacp enable !ports
	port: { <ports>: { vlacp: { enable: true } } }
spanning-tree bpduguard enable
	port: { <ports>: { spanning-tree: { bpdu-guard: { enable: true } } } }
no spanning-tree mstp  force-port-state enable
	port: { <ports>: { spanning-tree: { enable: false } } }
no spanning-tree mstp msti <msti> force-port-state enable
	port: { <ports>: { spanning-tree: { mstp: { msti: { <<msti>: { enable: false } } } } } }
no lldp status
	port: { <ports>: { lldp: { status: off } } }
eapol radius-dynamic-server enable
	port: { <ports>: { eapol: { radius-dynamic-server: true } } }
eapol status auto
	port: { <ports>: { eapol: { enable: <status:auto=true,authorized=false> } } }
eapol multihost radius-non-eap-enable
	port: { <ports>: { eapol: { multihost: { neap: { radius: true } } } } }
exit

# LINK-STATE TRACKING

# IP CONFIGURATION

# IP AS LIST CONFIGURATION - GlobalRouter

# IP AS LIST CONFIGURATION - VRF

# IP COMMUNITY LIST CONFIGURATION - GlobalRouter

# IP COMMUNITY LIST CONFIGURATION - VRF

# IP EXTENDED COMMUNITY LIST CONFIGURATION - GlobalRouter

# IP EXTENDED COMMUNITY LIST CONFIGURATION - VRF

# IP ROUTE MAP CONFIGURATION - GlobalRouter

# IP ROUTE MAP CONFIGURATION - VRF

# IP CONFIGURATION -  GlobalRouter
ip route <route> <mask> <ip> weight <weight>
	ip: { route: [{
		route: <route>
		mask: <mask>
		next-hop: <ip>
		weight: <weight>
		}]
	}

# IP CONFIGURATION -  VRF

# BFD CONFIGURATION -  GlobalRouter

# BFD CONFIGURATION -  VRF

# CIRCUITLESS IP INTERFACE CONFIGURATION - GlobalRouter

# CIRCUITLESS IP INTERFACE CONFIGURATION - VRF

# TOPOLOGY-CLIP-IP

# MSDP CONFIGURATION - GlobalRouter

# VRRP CONFIGURATION - GlobalRouter

# VRRP CONFIGURATION - VRF

# UDP FORWARDING CONFIGURATION - GlobalRouter

# UDP FORWARDING CONFIGURATION - VRF

# UDP FORWARDING VLAN CONFIGURATION

# DHCP CONFIGURATION - GlobalRouter

# DHCP CONFIGURATION - VRF

# RIP CONFIGURATION - GlobalRouter

# RIP CONFIGURATION - VRF

# RIP VLAN CONFIGURATION

# IGMP CONFIGURATION - GlobalRouter

# IGMP CONFIGURATION - VRF

# MROUTE CONFIGURATION

# MCAST RESOURCE USAGE CONFIGURATION

# MCAST RESOURCE USAGE CONFIGURATION

# TIMED PRUNE CONFIGURATION - GlobalRouter

# TIMED PRUNE CONFIGURATION - VRF

# RSMLT CONFIGURATION

# MLD CONFIGURATION - GlobalRouter

# MROUTE6 CONFIGURATION

# ISIS CONFIGURATION
router isis
sys-name <sysname>
	isis: { system-name: <sysname> }
is-type l1
system-id <sysid>
	isis: {system-id: <sysid> }
manual-area <area>
	isis: { area: <area> }
exit
router isis enable
	isis: { enable: true }

# LOGICAL ISIS CONFIGURATION

# VTEP CONFIGURATION

# REMOTE VTEP CONFIGURATIONS

# VLAN NODAL MEP/MIP CONFIGURATION

# QOS CONFIGURATION - PHASE II
qos queue-profile <n> member add <ports>
	qos: { queue-profile: { <n>: { ports: <ports> } } }
	port: { <ports>: { qos: { queue-profile: <n> } } }

# CFM CONFIGURATION - PHASE II
cfm spbm mepid <id>
	cfm: { spbm: { mepid: <id> } }
cfm spbm enable
	cfm: { spbm: { enable: true } }

# DIAG CONFIGURATION

# NTP CONFIGURATION
no ntp
	ntp: { enable: false }
ntp server <ip>
	ntp: { server: { <ip>: { enable: true } } }
ntp
	ntp: { enable: true }

#  OSPF CONFIGURATION - GlobalRouter

#  OSPF CONFIGURATION - VRF

# OSPF ACCEPT CONFIGURATION - GlobalRouter

# OSPF ACCEPT CONFIGURATION - VRF

# BGP CONFIGURATION - GlobalRouter

# BGP CONFIGURATION - VRF

# ISIS SPBM IPVPN CONFIGURATION

# IP ISID LIST CONFIGURATION - GlobalRouter

# IP ISID LIST CONFIGURATION - VRF

# ISIS ACCEPT CONFIGURATION - GlobalRouter

# ISIS ACCEPT CONFIGURATION - VRF

# ISIS IPv6 ACCEPT CONFIGURATION - GlobalRouter

# ISIS IPv6 ACCEPT CONFIGURATION - VRF

# IP REDISTRIBUTION CONFIGURATION - GlobalRouter

# IP REDISTRIBUTION CONFIGURATION - VRF

# OSPF VLAN CONFIGURATION

# OSPF PORT CONFIGURATION

# OSPF LOOPBACK CONFIGURATION

# RIP PORT CONFIGURATION

# IPVPN CONFIGURATION

# SLPP CONFIGURATION

# FILTER CONFIGURATION

# APPLICATION TELEMETRY CONFIGURATION

# IPV6 TUNNEL CONFIGURATION

# IPV6 OSPFV3 CONFIGURATION - GlobalRouter

# IPV6 RIPng CONFIGURATION

# IPV6 MGMT INTERFACE CONFIGURATION

# IPV6 STATIC ROUTE CONFIGURATION - GlobalRouter

# IPV6 MGMT INTERFACE CONFIGURATION

# IPV6 OSPF VLAN CONFIGURATION

# IPV6 OSPF PORT CONFIGURATION

# IPV6 RIP VLAN CONFIGURATION

# IPV6 RIP PORT CONFIGURATION

# IPV6 VRRP VLAN CONFIGURATION

# IPV6 VRRP PORT CONFIGURATION

# I-SID NAME CONFIGURATION
i-sid name <isid> <name>
	i-sid: { <isid>: { name: <name> } }

# I-SID CONFIGURATION
i-sid <!isid> <!type:elan,elan-transparent>
	i-sid: { <isid>: { type: <type> } }
untagged-traffic port <ports>
	i-sid: { <isid>: { ports: { <ports>: { tagging: untag } } } }
	port: { <ports>: { i-sid: { <isid>: { type: <type>, tagging: untag } } } }
c-vid <vid> port <ports>
	i-sid: { <isid>: { ports: { <ports>: { tagging: tagged, vlan-id: <vid> } } } }
	port: { <ports>: { i-sid: { <isid>: { type: <type>, tagging: tagged, vlan-id: <vid> } } } }
port <ports>
	i-sid: { <isid>: { ports: <ports> } }
	port: { <ports>: { i-sid: { <isid>: { type: <type> } } } }
untagged-traffic mlt <mltid>
	i-sid: { <isid>: { mlt: { <mltid>: { tagging: untag } } } }
	mlt: { <mltid>: { i-sid: { <isid>: { type: <type>, tagging: untag } } } }
c-vid <vid> mlt <mltid>
	i-sid: { <isid>: { mlt: { <mltid>: { tagging: tagged, vlan-id: <vid> } } } }
	mlt: { <mltid>: { i-sid: { <isid>: { type: <type>, tagging: tagged, vlan-id: <vid> } } } }
port mlt <mltid>
	i-sid: { <isid>: { mlt: <mltid> } }
	mlt: { <mltid>: { i-sid: { <isid>: { type: <type> } } } }
exit

# GLOBAL AUTO-SENSE CONFIGURATION
auto-sense voice i-sid <isid> c-vid <vid>
	auto-sense: {voice: {i-sid: <isid>, vlan-id: <vid> } }
auto-sense eapol voice lldp-auth
	auto-sense: {voice: {lldp-auth: true } }
auto-sense data i-sid 1234567
	auto-sense: {data: {i-sid: <isid> } }
auto-sense onboarding i-sid <isid>
	auto-sense: {onboarding: {i-sid: <isid> } }

# VNID CONFIGURATION

# RADIUS CONFIGURATION
radius server host <ip> [key <key>] [source-ip <ip>]
	radius: { server: { cli: { <ip>: { secret: <key:******=null>, source-ip: <ip> } } } }
radius server host <ip> [key <key>] used-by <used-by:cli,eapol,endpoint-tracking,snmp,web> [source-ip <ip>]
	radius: { server: { <used-by>: { <ip>: { secret: <key:******=null>, source-ip: <ip> } } } }
radius enable
	radius: { enable: true }
radius sourceip-flag
	radius: { source-ip-flag: true }
radius dynamic-server client <ip> secret <key> enable
	radius: { dynamic-server: { <ip>: { enable: true, secret: <key:******=null> } } }

# TACACS CONFIGURATION

# LLDP  CONFIGURATION

# EAP  CONFIGURATION
eapol enable
	eapol: { enable: true }

# FABRIC ATTACH CONFIGURATION

# ENDPOINT TRACKING CONFIGURATION

# SPB-PIM-GW CONFIGURATION

# SOFTWARE CONFIGURATION

#  APPLICATION CONFIGURATION

#  OVSDB CONFIGURATION

# IPSEC CONFIGURATION

# IPSEC POLICY TABLE CONFIGURATION

# IPSEC SA TABLE CONFIGURATION

# IPSEC SA POLICY LINK TABLE CONFIGURATION

# IPV6 OSPFV3 IPSEC CONFIGURATION

# IPV6 IPSEC INTERFACE CONFIGURATION

# IP IPSEC INTERFACE CONFIGURATION

# IKE CONFIGURATION

#  SYSTEM CONFIGURATION Phase 2

# ISIS MULTI-AREA CONFIGURATION

end

# IP REDISTRIBUTE APPLY CONFIGURATIONS

# IP ECMP APPLY CONFIGURATIONS

# IP MULTI-AREA APPLY CONFIGURATIONS

=cut

################################################################################
#                    PERL Post-Processing of Data Structure                    #
################################################################################
#
# Perl code can begin here.
# This code can be used to coerce the extracted data into the desired schema.
# Must be a subroutine named "run"
# This code is called after the all the data has been extracted from the original config file
# and it allows us to alter the structure of the data to comply with the data schema we are aiming for
# Note that keys containing '-' character must be quoted...

use Data::Dumper;
use Storable 'dclone';

sub run { # Function must be named "run" and will be executed as Encoder::run
	my $data = shift; # The extracted data structure is passed as a hash reference

	# When we encode VLAN port membership we capture all the ports: 
	#	vlan members [add] <vids> <ports>
	#		vlan: { <vids>: { ports-all: <ports> } }
	#
	# but we need the data structure to store which ports are added as tagged and which as untagged.
	# This is in case we need to makecfg to EXOS or Switchd UNI VOSS
	# So we parse the ports tagging mode and pvid (in case of untagPvidOnly) and we create these 2 new keys:
	#
	#		vlan: { <vids>: { ports-untagged: <ports>, ports-tagged: <ports> } }
	#
	for my $vlan (keys %{$data->{vlan}}) {
		$vlanRef = $data->{vlan}->{$vlan};
		next unless exists $vlanRef->{'ports-all'};
		@vlanPortList = split(',', main::generatePortList($vlanRef->{'ports-all'}));
		my (@untagPorts, @taggedPorts);
		for my $port (@vlanPortList) {
			my $portRef = $data->{port}->{$port};
			unless (exists $portRef->{tagging}) { # Key not set = port is in default untagAll
				push(@untagPorts, $port);
				next;
			}
			if ($portRef->{tagging} eq 'tagAll') {
				push(@taggedPorts, $port);
			}
			elsif ($portRef->{tagging} eq 'unTagPvidOnly' && $portRef->{pvid} == $vlan) {
				push(@untagPorts, $port);
			}
			else { # unTagPvidOnly and pvid != $vlan
				push(@taggedPorts, $port);
			}
		}
		$vlanRef->{'ports-untagged'} = main::generateRange(join(',', @untagPorts), 1) if @untagPorts;
		$vlanRef->{'ports-tagged'} = main::generateRange(join(',', @taggedPorts), 1) if @taggedPorts;
	}

}

1;

__END__
