package Encoder;
my $Version = "0.04";

# BOSS config to json (c2j) encoder
# Ensure that j2c decoder is of same major version to ensure operating on same data schema

=ignore

################################################################################
#                                    SYNTAX                                    #
################################################################################
# Special directives:
#	SCHEMA_BEGIN			: Marks beginning of schema
#	SCHEMA_END			: Marks end of schema; all lines between SCHEMA_BEGIN and SCHEMA_END are treated like comments
# 	COMMENT_LINE = "<char>"		: Set the character which if seen at beginning of device config line makes the line a comment
#					  This is needed to skip comment lines when parsing a config
#	PORT_ALL = 1-<X>		: This sets what the highest number of expected ports is on a given slot, and is used to generate
#					  a port list when the device lists ports a <slot>/ALL, as BOSS does. If not set, 99 is assumed.
#	CLEAR_PERSIST_CONTEXT = "<cmd>" : Command which indicates exiting a configuration context, used to forget last persistent variable
#	DEFAULTS			: In the following lines provide space or tab indented json initialization values
#
# Then simply provide exhaustive list of lines expected to be found in config file, each line followed with the desired json encoding of data
# extracted from that line. Arguments withing the config line can be encoded as <arg>. The json encoding lines which follow must be space or
# tab indented. Or the first json line must begin with '{' and the last line must end with '}'.
# All json encodings supported. Hash of hashes, array of hashes and hashes of arrays...
#
# Example1 (pretty - no outer curlies):
# vlan create <vid> name <name type port <inst>
#	vlan: {
#		<vid>: {
#			name: <name>
#			instance: <inst>
#		}
#	}
#
# Example2 (pretty - with outer curlies):
# vlan create <vid> name <name type port <inst>
# {
#	vlan: {
#		<vid>: {
#			name: <name>
#			instance: <inst>
#		}
#	}
# }
#
# Example3 (compact):
# vlan create <vid> name <name type port <inst>
#	vlan: {	<vid>: { name: <name>, instance: <inst> } }
#
# Example4 (using array list with square brackets):
# ip name-server <ip>
#	dns: { server: [<ip>] }
#
# The json syntax is forgiving in that commas don't need to placed at end of lines.
# If the json syntax is found to be invalid an error will detail the line and why.
# If in doubt refer to JSON syntax.
# Make sure the schema is sensible; for example if the VLAN-id is used as the sub-key for the 'vlan' key, make sure that only VLAN-ids are used as
# sub-keys for the 'vlan' key. 
#
# Arguments <arg> syntax inside command line:
#	<name>			: Argument variable which will accepts any string
#	<name:1-10>		: Argument variable which will accept a number between 1 and 10
#	<name:1-10,>		: Argument variable which will accept a list and/or range of numbers where all numbers must be between 1 and 10
#	<name:value1,value2,etc>: Argument variable which will accept only discrete values: "value1" or "value2" or ect..
#	<name:*>		: Argument variable which will glob the rest of the command line
#	<port>			: When name = 'port', the argument variable only accepts a single valid port for the connected host (or in the defined input port range)
#	<ports>			: When name = 'ports', the argument variable accepts a list and/or range of valid ports for the connected host (or in the defined input port range)
#	<ip>			: When name = 'ip', the argument only accepts an IPv4 address
#	<ipv6>			: When name = 'ipv6', the argument only accepts an IPv6 address
#	<ip:mask>		: Accepts an IPv4/masklen address; can use <ip> for ip address, <mask> dotted mask, <masklen> mask bits 
#	<ipv6:mask>		: Accepts an IPv6/masklen address; can use <ip> for ip address, <mask> mask bits 
#
# Arguments <arg> syntax inside json lines:
# 	<var:%>			: true if set else false 
# 	<var:!%>		: false if set else true 
#	<var:abc=1,def=xyz,...>	: Mapping of argument values; e.g. if argument <var> has value 'abc' then encode in json as 1; etc..
#
# You can also reference data already in the data structure using the same json var syntax as in the decode.j2c file:
#	$<key1>{key2}[idx1]{key3}
#
# If an argument is a list of values, and the <arg> is used either as a json key [not array list], then as many keys will be expanded in the json encoding.
#
# For example this definition:
#
# vlan create <vids> type port <inst>
#	vlan: {	<vids>: { instance: <inst> } }
#
# When used to encode this config line: vlan create 1-3,5 type port 1
# Will result in this json encoding:
#	vlan: {
#		1: {
#			instance: 1
#		},
#		2: {
#			instance: 1
#		},
#		3: {
#			instance: 1
#		},
#		5: {
#			instance: 1
#		},
#	}
#
#
# Arguments <arg> hold their values only while processing the current config line. But it is also possible to hold argument values persistently.
# This is done by inserting a "!" like <!arg>. For example, if we wanted to json encode these lines:
#
# interface vlan 200
# ip address 10.0.200.1 255.255.255.0 1
# exit
#
# And assume that we wanted to store the IP/mask under the vlan key. This can be achieved with these definitions:
#
# interface vlan <!vid>
# ip address <ip> <mask> [<macoffset>]
# 	vlan: { <vid>: { ip: <ip>, mask: <mask> } }
# exit
#
# In practice the argument values are held in 2 separate tables, one persistent and one not.
# When a lookup is performed in the json encoding, first a lookup is performed in the non-persistent table, and if no value is found there, then a lookup
# is performed in the persistent table.
#
# Some configuration, using identical CLI commands, can apply to different contexts, for example global context or VLAN or Port or MLT context.
# In order to encode the config in the correct context, the definitions can require that a variable be set in the persistent table and also that that
# variable was the most recent variable set in the persistent table. For example:
#
# interface mlt 62
# isis enable
# exit
#
# -and-
#
# interface gigabitEthernet 1/2
# isis enable
# exit
#
# The "isis enable" command is the same, yet it applies to different configuration contexts, which will need to be encoded as follows.
# 
# interface mlt <!mltid>
# isis enable !mltid
# 	mlt: { <mltid> : {isis: { enable: true } } }
# exit
#
# interface GigabitEthernet <!ports>
# isis enable !ports
#	port: { <ports>: {isis: { enable: true } } }
# exit
#
# Specifying either "!mltid" or "!ports" as the last keyword of the "isis enable" command, allows each to be encoded as a different command
# with a different encoding. When the "isis enable" is encountered, the most recently set variable in the persistent table will determine which
# is used to encode the command.
#
# The very same problem, but using an example between port context and global context.
#
# lacp enable
#
# -and-
#
# interface GigabitEthernet 1/3
# lacp enable
# exit
#
# This time the "lacp enable" command applies to the global context as well as to port context. To differentiate between the two we can use use
# these definitions.
#
# lacp enable !
# 	lacp: { enable: true }
#
# interface GigabitEthernet <!ports>
# lacp enable !ports
# 	port: { <ports>: { lacp: { enable: true } } }
# exit
#
# By specifying the single "!" after that "lacp enable" command, we are making sure that the definition will only apply when no persistent
# variable is set. Normally global commands precede interface context config commands, but what would happen if that was not the case ?
# In order to clear the last persistent variable name, the following directive can be specified:
#
# CLEAR_PERSIST_CONTEXT = "exit"
#
# Now when the "exit" command is seen, the last stored persistent variable is cleared.
#
#
# If we wanted to encode data into a different part of the schema, we can back reference data already in the structure.
# For example, if we encoded these lines:
# interface vlan 190
# ip address 10.120.200.1 255.255.248.0 4
# [...later in same config...]
# ip dhcp-relay fwd-path 10.120.200.1 164.166.4.18 
# ip dhcp-relay fwd-path 10.120.200.1 164.166.4.18 mode dhcp
#
# We can use this encoding:
#
# interface vlan <!vid>
# ip address <ip> <mask> <macoffset:0-999>
#	vlan: { <vid>: { ip: <ip>, mask: <mask> } }
#	ip: { interface: { <ip>: { mask: <mask>, vlan: <vid> } } }
# exit
# ip dhcp-relay fwd-path <ip> <srv> [mode <mode>]
#	vlan: { $ip{interface}{<ip>}{vlan}: { dhcp-relay: { server: <srv>, mode: <mode> } } }
#
# Notice the use above of $ip{interface}{<ip>}{vlan}, which harks back to the data structure to retrieve the vlan-id for the IP address.
# This is handy if we want the vlan dhcp-relay info to be stored under the corresponding vlan key
#
#
# Best to avoid assigning key and value directly as this:
#
# banner <n> <line>
# 	system: { banner: { custom: { <n>: <line> } } }
#
# Because in the j2c file, variable $system{banner}{custom}{x} will only refer to the keys, not the values; one will have to use the more cryptic
# $system{banner}{custom}{x:v} to get to the values
#
# If possible, it is better to use a sub-hash like this:
#
# banner <n> <line>
#	system: { banner: { custom: { <n>: {line: <line> } } } }
#
# So that in j2c file the keys can be expressed as $system{banner}{custom}{x} and the values as $system{banner}{custom}{x}{line}
#
#
# Config lines which present no useful data to extract, can be included without any json encoding on following lines.
# This will ensure those lines do not throw errors when parsed. These lines can also set persistent <!arg> arguments.
#
#
################################################################################
#                                    SCHEMA                                    #
################################################################################
SCHEMA_BEGIN	# Schema is not actually read in by rosetta.pl

	Omitted, can be obtained with: rosetta.pl schema <this-file.c2j> [<out-schema-file>]

SCHEMA_END	# Only lines after this one will actially be read in 


################################################################################
#                                  DEFINITIONS                                 #
################################################################################

COMMENT_LINE = "!"
PORT_ALL = 1-50
DEFAULTS
	system: { autosave: true }
	system: { audit-log: true }
	system: { banner: true, type: static }
	system: { vlan: { auto-pvid: true } }
	ssh: { client: { enable: true } }
	telnet: { client: { enable: true } }
	cli: { timestamp: true }
	stack: { quickconfig: { enable: false } } 
	serial-port: { security: false }
	serial-port: { enable: true }
	usb: { enable: true }
	system: { mtu: 9216, jumbo: true }
	radius: { encapsulation: pap }
	web: { enable: true }
	mgmt-access-control: { telnet: true, snmp: true, web: true, ssh: true }
	ipfix: { use-management-ip: true }
	sonmp: { enable: true }
	dhcp-relay: {enable: true}
	radius: { use-management-ip: true }
	radius: { password-fallback: true }
	stack: {forced-mode: false}
	stack: {reboot-on-failure: true}
	stack: { auto-unit-replacement: { enable: true } }
	stack: { auto-unit-replacement: { auto-save: true } }
	stack: { auto-unit-replacement: { image-update: true } }
	fabric-attach: { forward-mgmt-vlan: true }
	ip: { routing: false }
	mgmt: { vlan: { vlan-id: 1 } }
	vlan: { 1: { mgmt: true } }

# Lines where we extract no json:
enable
configure terminal
interface Ethernet <!ports>
interface vlan <!vid>
router <!rtr:ospf,rip,isis,vrrp>
exit
end


! *** AAA ***
password security
	password: {security: { enable: true } }
password aging-time <days>
	password: {security: { aging-time: <days> } }
password password-history <hist>
	password: {security: { history: <hist> } }
password complexity lower-case <num>
	password: {security: { lower-case: <num> } }
password complexity numeric <num>
	password: {security: { numeric: <num> } }
password complexity special <num>
	password: {security: { special: <num> } }
password complexity upper-case <num>
	password: {security: { upper-case: <num> } }
password min-length <len>
	password: {security: { min-length: <len> } }
password notifications <num>
	password: {security: { notifications: <num> } }
password check-sequential <ena:enable,disable>
	password: {security: { check-sequential: <ena:enable=true,disable=false> } }
password check-repeated <ena:enable,disable>
	password: {security: { check-repeated: <ena:enable=true,disable=false> } }
password delay-time <time>
	password: {security: { delay-time: <time> } }
password password-change-rate-limiter <numb>
	password: {security: { change-rate-limiter: <numb> } }
password password-change-on-first-login <ena:enable,disable>
	password: {security: { change-on-first-login: <ena:enable=true,disable=false> } }
password unlock-timer <numb>
	password: {security: { unlock-timer: <numb> } }
password login-failure-notification <notification>
	password: {security: { login-failure-notification: <notification> } }

! *** CORE (Phase 1) ***
no autosave enable
	system: { autosave: false }
no audit log
	system: { audit-log: false }
mac-address-table aging-time <secs>
	system: { vlan: { aging-time: <secs> } }
no autotopology
	sonmp: { enable: false }
sntp server primary address <ip>
	sntp: { server: [<ip>] }
sntp server secondary address <ip>
	sntp: { server: [<ip>] }
sntp enable
	sntp: { enable: true }
sntp sync-interval <int>
	sntp: { sync-interval: <int> }
ntp server <ip> enable
	ntp: { server: { <ip>: { enable: true } } }
ntp
	ntp: { enable: true }
telnet-access login-timeout <numb>
	cli: {login-timeout: <numb> }
telnet-access retry <numb>
	cli: {login-retry: <numb> }
telnet-access inactive-timeout <time>
	cli: {inactive-timeout: <time> }
telnet-access logging <lev:all,access,failures,none>
	cli: {logging: { level: <lev> } }
terminal width <width>
	terminal: { width: <width> }
terminal length <length>
	terminal: { length: <length> }
no remote connection enable
	ssh: { client: { enable: false } }
	telnet: { client: { enable: false } }
no cli timestamp enable
	cli: { timestamp: false }
quickconfig enable
	stack: { quickconfig: { enable: true } } 

cli password serial <src:local,radius,tacacs,none>
	cli: { password: { serial: <src> } }
cli password telnet <src:local,radius,tacacs,none>
	cli: { password: { telnet: <src> } }
	cli: { password: { ssh: <src> } }
script <num> <source> <args:*>
tftp-server <ip>
	tftp: { server: <ip> }
http-port <tcpport>
	web: { http-port: <tcpport> }
serial-security enable
	serial-port: { security: true }
no serial-console enable
	serial-port: { enable: false }
no serial-console unit <unit> enable
	serial-port: { unit: { <unit>: { enable: false } } }
no usb-host-port enable
	usb: { enable: false }
no usb-host-port unit <unit> enable
	usb: { unit: { <unit>: { enable: false } } }
jumbo-frames enable size <mtu>
	system: { mtu: <mtu>, jumbo: true }
no jumbo-frames [enable]
	system: { mtu: 1518, jumbo: false }
edm help-file-path <path> tftp address <ip>
	edm: { help-file: { path: <path>, tftp-address: <ip> } }
edm inactivity-timeout <secs>
	edm: { inactivity-timeout: <sec> }

! *** RADIUS ***
no radius-server password fallback
	radius: { password-fallback: false }
radius-server encapsulation <encap:pap,ms-chap-v2>
	radius: { encapsulation: <encap> }
no radius use-management-ip
	radius: { use-management-ip: false }
radius server host <ip> [<scd:secondary>] [<acct:acct-enable>] [timeout <timeout>]
	radius: {
		server: {
			<ip> : {
				accounting: <acct:%>
				timeout: <timeout>
			}
		}
	}
radius server host timeout <tm>
radius server host used-by eapol timeout <tm>
radius server host used-by non-eapol timeout <tm>
radius accounting interim-updates enable
	radius: { interim-updates: { enable: true } }
radius accounting interim-updates interval <interval>
	radius: { interim-updates: { interval: <interval> } }
no radius accounting interim-updates use-server-interval
	radius: { interim-updates: { use-server-interval: false } }
radius reachability mode <mode:use-radius,use-icmp> [username <usr>] [password <pwd>]
	radius: {
		reachability: {
			mode: <mode>
			username: <usr>
			password: <pwd>
		}
	}
radius reachability timeout <time>
	radius: {reachability: { timeout: <time> } }
radius reachability retry <retries>
	radius: {reachability: { retry: <retries> } }
radius reachability bad-timer <timer>
	radius: {reachability: { bad-timer: <timer> } }
radius reachability good-timer 180
	radius: {reachability: { good-timer: <timer> } }

! *** RADIUS Dynamic Server ***
radius dynamic-server replay-protection
	radius: { dynamic-server: { replay-protection: true } }
radius dynamic-server client <ip> [port <udpport>]
	radius: {
		dynamic-server: {
			client: {
				<ip>: {
					port: <udpport>
					secret: null
				}
			}
		}
	}
radius dynamic-server client <ip> [<reauth:process-reauthentication-requests>] [<disc:process-disconnect-requests>] [<coa:process-change-of-auth-requests>]
	radius:{
		dynamic-server: {
			client: {
				<ip>: {
					reauthentication: <reauth:%>
					disconnect: <disc:%>
					coa: <coa:%>
				}
			}
		}
	}

! *** TACACS+ ***
tacacs server host <ip>
	tacacs: { server: [<ip>] }
tacacs server secondary-host  <ip>
	tacacs: { server: [<ip>] }
tacacs server port <tcp>
	tacacs: { tcp-port: <tcp> }
tacacs server retry <retries>
	tacacs: { retry: <retries> }
tacacs authorization enable
	tacacs: { authorization: { enable: true } }
tacacs authorization level <lev:ALL,LINE,NONE>
	tacacs: { authorization: { level: <lev> } }
tacacs accounting enable
	tacacs: { accounting: true }

! *** SNMP ***
snmp-server enable
	snmp: {enable: true}
snmp-server contact <contact>
	system: { contact: <contact> }
snmp-server name <sysname>
	system: { name: <sysname> }
snmp-server location <location>
	system:{ location: <location> }
snmp-server view <name> <oid>
	snmp: { view: { <name>: <oid> } }
snmp-server user <user> <auth:sha,md5> [<priv:des,aes>] [read-view <rdview>] [write-view <rwview>] [notify-view <nfview>]
	snmp: { user:{<user>: {
		auth: <auth>
		priv: <priv>
		read-view: <rdview>
		write-view: <rwview>
		notify-view: <nfview>
	}}}
snmp-server notify-filter <bigid> <mib>
	snmp: { notify-filter: [ { profile: <bigid>, oid: <mib> } ] }
snmp-server host <host> port <udpport> <version:v1,v2c,v3> auth <user> [<inform:inform>] [filter <bigid>]
	snmp: { host: {
		<host>: {
			port: <udpport>
			version: <version>
			user: <user>
			trap: <inform:!%>
			inform: <inform:%>
			filter: <bigid>
		}
	}}
snmp-server notification-control <trap>
	snmp: { notification-control: { <trap>: { enable: true } } }
snmp-server notification-control <trap> <ports>
	snmp: { notification-control: { <trap>: { enable: true, ports: <ports> } } }
no snmp-server notification-control <trap>
	snmp: { notification-control: { <trap>: { enable: false } } }
no snmp-server notification-control <trap> <ports>
	snmp: { notification-control: { <trap>: { enable: false, ports: <ports> } } }

! *** IP  ***
ip default-gateway <ip>
	mgmt: { vlan: { default-gateway: <ip> } }
ip address switch <ip>
	mgmt: { vlan: { ip: <ip> } }
	ip: { interface: { <ip>: { mgmt-vlan: true } } }
ip address stack <ip>
	mgmt: { vlan: { ip: <ip> } }
	ip: { interface: { <ip>: { mgmt-vlan: true } } }
ip address unit <unit> <ip>
ip [address] netmask <mask>
	mgmt: { vlan: { mask: <mask> } }
	ip: { interface: { $mgmt{vlan}{ip}: { mask: <mask> } } }
ip address source <mode>
	mgmt: { vlan: { source: <mode> } }
ip domain-name <domain>
	dns: { domain-name: <domain> }
ip name-server <ip>
	dns: { server: [<ip>] }
ip mgmt netmask <mask>
	mgmt: { oob: { mask: <mask> } }
ip mgmt address switch <ip>
	mgmt: { oob: { ip: <ip> } }
ip mgmt address stack <ip>
	mgmt: { oob: { ip: <ip> } }
ip mgmt default-gateway <ip>
	mgmt: { oob: { default-gateway: <ip> } }
ip mgmt address unit <unit> <ip>
ip mgmt limit <pps>
	mgmt: { oob: { pps-limit: <pps> } }
ip mgmt shutdown-interval <secs>
	mgmt: { oob: { shutdown-interval: <secs> } }

! *** IP Manager ***
telnet-access disable
	telnet: { enable: false }
no web-server enable
	web: { enable: false }
no ipmgr <protocol:telnet,snmp,web,ssh>
	mgmt-access-control: { <protocol> : false }
ipmgr source-ip <n> <ipv6:mask>
	mgmt-access-control: { rule: { <n>: {
		network: <ipv6>
		mask: <mask>
	} } }
ipmgr source-ip <n> <ip>
	mgmt-access-control: { rule: { <n>: {
		network: <ip>
		mask: 255.255.255.255
	} } }
ipmgr source-ip <n> <ip> mask <mask>
	mgmt-access-control: { rule: { <n>: {
		network: <ip>
		mask: <mask>
	} } }

! *** ASSET ID ***
asset-id [stack] <asset>
	system: { asset-id: { main: <asset> } }
asset-id unit <unit> <asset>
	system: { asset-id: { unit: { <unit> : <asset> } } }

! *** IPFIX ***
ip ipfix slot <slot> aging-interval <interval>
	ipfix: { slot: { <slot>: { aging-interval: <interval> } } }
ip ipfix slot <slot>  active-timeout <timeout>
	ipfix: { slot: { <slot>: { active-timeout: <timeout> } } }
ip ipfix export-interval <interval> [<expena:exporter-enable>] [template-refresh-interval <int>] [template-refresh-packets <pkts>]
	ipfix: {
		export-interval: <interval>
		exporter-enable: <expena:%>
		template-refresh-interval: <int>
		template-refresh-packets: <pkts>
	}
no ip ipfix collector use-management-ip
	ipfix: { use-management-ip: false }
interface Ethernet ALL
ip ipfix port <ports> enable
	port: { <ports>: { ipfix: { enable: true } } }
exit
ip ipfix enable
	ipfix: { enable: true }

! *** System Logging ***
no logging enable
	logging: { enable: false }
logging [enable] level <lev:informational,critical,seriuos,none> [nv-level <nvlev:critical,none,serious>]
	logging: { level: <lev>, non-volatile-level: <nvlev> }
logging volatile <mode:overwrite,latch>
	logging: { overflow: <mode> }
logging remote address <ip>
	syslog: { 1: { server: <ip> } }
	syslog: { 1: { enable: true } }
logging remote secondary-address <ip>
	syslog: { 2: { server: <ip> } }
	syslog: { 2: { enable: true } }
logging remote enable
	syslog: { enable: true }
logging remote facility <facility>
	syslog: { 1: { facility: <facility> } }
	syslog: { 2: { facility: <facility> } }
logging remote level <level>
	syslog: { 1: { level: <level> } }
	syslog: { 2: { level: <level> } }

! *** STACK ***
stack forced-mode
	stack: { forced-mode: true}
no stack reboot-on-failure
	stack: { reboot-on-failure: false}
stack retry-count <cnt>
	stack: { retry-count: <cnt> }

! *** Custom Banner ***
no banner
	system: { banner: { enable: false } }
banner static
	system: { banner: { type: static } }
banner disabled
	system: { banner: { enable: false } }
banner <n> <line>
	system: { banner: { type: custom, custom: [<line>] } }

! *** Certificates Settings ***
! --- Certificate Subject ---
certificate subject common-name <name>
	certificate: { subject: { common-name: <name> } }
certificate subject country <country>
	certificate: { subject: { country: <country> } }
certificate subject e-mail <e-mail>
	certificate: { subject: { e-mail: <e-mail> } }
certificate subject fqdn <fqdn>
	certificate: { fqdn: <fqdn> }
certificate subject include-ip-address <iipa:true,false>
	certificate: { subject: { include-ip-address: <iipa> } }
certificate subject locality <loc:*>
	certificate: { subject: { locality: <loc> } }
certificate subject organization <org:*>
	certificate: { subject: { organization: <org> } }
certificate subject province <prov>
	certificate: { subject: { province: <prov> } }
certificate subject unit <unit>
	certificate: { subject: { unit: <unit> } }
! --- Certificate Authority ---
certificate ca <caname>
	certificate: { ca: { <caname>: {} } }
certificate ca <caname> common-name <cname>
	certificate: { ca: { <caname>: { common-name: <cname> } } }
certificate ca <caname> key-name <kname>
	certificate: { ca: { <caname>: { key-name: <kname> } } }
certificate ca <caname> ca-url <url>
	certificate: { ca: { <caname>: { ca-url: <url> } } }
certificate ca <caname> use-for <for:ike,ssh-server,ssl-server>
	certificate: { ca: { <caname>: { use-for: <for> } } }
certificate ca <caname> use-post <truefalse>
	certificate: { ca: { <caname>: { use-post: <truefalse> } } }
certificate ca <caname> regenerate-key-on-re-enroll
	certificate: { ca: { <caname>: { regenerate-key-on-re-enroll: true } } }
certificate ca <caname> validity <days>
	certificate: { ca: { <caname>: { validity: <days> } } }
certificate ca <caname> auto-renew
	certificate: { ca: { <caname>: { auto-renew: true } } }

! --- Certificate Key ---
! --- Certificates in CA ---
! --- Certificates in TrustStore ---

! *** SSH ***
ssh port <tcpport>
	ssh: { tcp-port: <tcpport> }
ssh timeout <timeout>
	ssh: { timeout: <timeout> }
no ssh pass-auth
	ssh: { pass-auth: false }
no ssh dsa-auth
	ssh: { dsa-auth: false }
no ssh rsa-auth
	ssh: { rsa-auth: false }
ssh x509v3-auth
	ssh: { x509v3: { enable: true } }
ssh x509v3-auth username <mode:overwrite,strip-domain,use-domain>
	ssh: { x509v3: { username: { <mode>: true } } }
ssh x509v3-auth  revocation-check-method <meth:ocsp,none>
	ssh: { x509v3: { revocation: <meth> } }
ssh retries <retries>
	ssh: { retries: <retries> }
ssh rekey
	ssh: { rekey: true }
ssh rekey-interval <int>
	ssh: { rekey-interval: <int> }
ssh rekey-datalimit <gb>
	ssh: { rekey-datalimit: <gb> }
ssh
	ssh: { enable: true }
! *** SSL ***
ssl
	web: { ssl: true }
no https-only
	web: { http: true, https: true}
https-port <tcpport>
	web: { https-port: <tcpport> }

! *** SSHC ***
sshc port <tcpport>
	ssh: { client: { tcpport: <tcpport> } }
sshc rekey <gb>
	ssh: { client: { rekey-datalimit: <gb> } }
sshc authentication <type:password,dsa,rsa>
	ssh: { client: { authentication: <type> } }
sshc dsa-key <keysize>
	ssh: { client: { dsa-key: <keysize> } }
sshc rsa-key <keysize>
	ssh: { client: { rsa-key: <keysize> } }
sftp-server <ip>
	ssh: { sftp-server: <ip> }

! *** MSTP (Phase 1) ***
spanning-tree mode mst
	spanning-tree: { mode: mstp }
spanning-tree mstp forward-time <secs>
	spanning-tree: { forward-time: <secs> }
spanning-tree mstp max-age <secs>
	spanning-tree: { max-age: <secs> }
spanning-tree mstp max-hop <hops>
	spanning-tree: { max-hop: <hops> }
spanning-tree mstp pathcost-type <bits:bits32,bits16>
	spanning-tree: { pathcost-type: <bits> }
spanning-tree mstp priority <priority>
	spanning-tree: { priority: <priority> }
spanning-tree mstp region config-id-sel <sel>
	spanning-tree: { mstp: { region: { config-id-sel: <sel> } } }
spanning-tree mstp region region-name <name>
	spanning-tree: { mstp: { region: { name: <name> } } }
spanning-tree mstp region region-version <ver>
	spanning-tree: { mstp: { region: { version: <ver> } } }
spanning-tree mstp tx-holdcount <cnt>
	spanning-tree: { tx-holdcount: <cnt> }
spanning-tree mstp version <ver:mstp,rstp,stp-compatible>
	spanning-tree: { mstp: { version: <ver> } }
spanning-tree bpdu-filtering ignore-self
	spanning-tree: { bpdu-guard: { ignore-self: true } }

! *** LACP (Phase 1) ***
interface Ethernet ALL
lacp mode port <ports> off
	port: { <ports>: { lacp: {
		enable: false
	}}}
exit

! *** VLAN ***
vlan configcontrol <mode:automatic,autopvid,flexible,strict>
	system: { vlan: { configcontrol: <mode> } }
vlan create <vids> type <type> [<inst:cist>] [<inst:1-8>] [<vvln:voice-vlan>]
	vlan: {
		<vids>: {
			type: <type>
			instance: <inst:cist=0>
			voice-vlan: <vvln:%>
		}
	}
vlan name <vid> <name>
	vlan: { <vid>: { name: <name> } }
vlan ports <ports> [priority <priority>] [name <name>]
	port: {
		<ports>: {
			qos: <priority>
			name: <name>
		}
	}
vlan ports <ports> tagging <tagging:tagAll,untagAll,unTagPvidOnly> [filter-untagged-frame <funt:enable,disable>] [filter-unregistered-frames <funr:enable,disable>] [priority <priority>]
	port: {
		<ports>: {
			tagging: <tagging>
			filter-untagged-frame: <funt:enable=true,disable=false>
			filter-unregistered-frames: <funr:enable=true,disable=false>
			qos: { priority: <priority> }
		}
	}
vlan ports <ports> private-vlan <type:isolated,promiscuous,trunk>
	port: { <ports>: { private-vlan: <type> } }
vlan members <vids> none
	vlan: { <vids>: { ports-all: null } }
vlan members [add] <vids> <ports>
	vlan: { <vids>: { ports-all: <ports> } }
vlan ports <ports> pvid <pvid>
	vlan: { <pvid>: {pvid: [<ports>] } }
	port: { <ports>: { pvid: <pvid> } }
no auto-pvid
	system: { vlan: { auto-pvid: false } }

! *** 802.1ab ***
lldp [tx-interval <txint>] [tx-hold-multiplier <mltp>] [reinit-delay <inidly>] [tx-delay <txdly>] [notification-interval <nfint>] [med-fast-start <cnt>]
	lldp: {
		tx-interval: <txint>
		tx-hold-multiplier: <mltp>
		reinit-delay: <inidly>
		tx-delay: <txdly>
		notification-interval: <nfint>
		med-fast-start: <cnt>
	}
interface Ethernet ALL
lldp port <ports> status <status:txAndRx,rxOnly,txOnly>
	port: { <ports>: { lldp: { status: <status> } } }
lldp port <ports> config-notification
	port: { <ports>: { lldp: { config-notification: true } } }
no lldp port <ports> config-notification
	port: { <ports>: { lldp: { config-notification: false } } }
lldp tx-tlv [<lclma:local-mgmt-addr>] [<prtdsc:port-desc>] [<syscap:sys-cap>] [<sysdsc:sys-desc>] [<sysnam:sys-name>]
	port: { <ports>: { lldp: { tx-tlv: {
		local-mgmt-addr: <lclma:%>
		port-description: <prtdsc:%>
		system-capabilities: <syscap:%>
		system-description: <sysdsc:%>
		system-name: <sysnam:%>
	} } } }
no lldp tx-tlv [<lclma:local-mgmt-addr>] [<prtdsc:port-desc>] [<syscap:sys-cap>] [<sysdsc:sys-desc>] [<sysnam:sys-name>]
	port: { <ports>: { lldp: { tx-tlv: {
		local-mgmt-addr: <lclma:!%>
		port-description: <prtdsc:!%>
		system-capabilities: <syscap:!%>
		system-description: <sysdsc:!%>
		system-name: <sysnam:!%>
	} } } }
no lldp tx-tlv dot1 port-protocol-vlan-id [<ports>] <pvid:port-vlan-id>
	port: { <ports>: { lldp: { tx-tlv: { dot1: {
		port-vlan-id: <pvid:!%>
	} } } } }
lldp tx-tlv dot1 port-protocol-vlan-id [<ports>] [<pvid:port-vlan-id>] [protocol-identity <pi:EAP,LLDP,STP>] [<pi2:EAP,LLDP,STP>] [<pi3:EAP,LLDP,STP>] [vlan-name <vids>]
	port: { <ports>: { lldp: { tx-tlv: { dot1: {
		port-vlan-id: <pvid:%>
		protocol-identity: [<pi>, <pi2>, <pi3>]
		vlan-name: <vids>
	} } } } }
lldp tx-tlv port <ports> dot3 [<lkag:link-aggregation>] [<macst:mac-phy-config-status>] [<mfs:maximum-frame-size>] [<mdipwr:mdi-power-support>]
	port: { <ports>: { lldp: { tx-tlv: { dot3: {
		link-aggregation: <lkag:%>
		mac-phy-config-status: <macst:%>
		maximum-frame-size: <mfs:%>
		mdi-power-support: <mdipwr:%>
	} } } } }
no lldp tx-tlv port <ports> dot3 [<lkag:link-aggregation>] [<macst:mac-phy-config-status>] [<mfs:maximum-frame-size>] [<mdipwr:mdi-power-support>]
	port: { <ports>: { lldp: { tx-tlv: { dot3: {
		link-aggregation: <lkag:!%>
		mac-phy-config-status: <macst:!%>
		maximum-frame-size: <mfs:!%>
		mdi-power-support: <mdipwr:!%>
	} } } } }
lldp tx-tlv port <ports> med [<expse:extendedPSE>] [<inv:inventory>] [<loc:location>] [<medcp:med-capabilities>] [<netpol:network-policy>]
	port: { <ports>: { lldp: { tx-tlv: { med: {
		extendedPSE: <expse:%>
		inventory: <inv:%>
		location: <loc:%>
		med-capabilities: <medcp:%>
		network-policy: <netpol:%>
	} } } } }
no lldp tx-tlv port <ports> med [<expse:extendedPSE>] [<inv:inventory>] [<loc:location>] [<medcp:med-capabilities>] [<netpol:network-policy>]
	port: { <ports>: { lldp: { tx-tlv: { med: {
		extendedPSE: <expse:!%>
		inventory: <inv:!%>
		location: <loc:!%>
		med-capabilities: <medcp:!%>
		network-policy: <netpol:!%>
	} } } } }
#default lldp location-identification civic-address
#default lldp location-identification coordinate-base
#default lldp location-identification ecs
exit

! *** 802.1ab vendor-specific TLVs config ***
lldp vendor-specific [avaya] call-server <n> <ip>
	lldp: {	vendor-specific: [<ip>] }
lldp vendor-specific [avaya] file-server <n> <ip>
	lldp: {	file-server: [<ip>] }
interface Ethernet ALL
lldp port <ports> vendor-specific poe-conservation-request-level <lvl>
	port: { <ports>: { lldp: { vendor-specific: { poe-conservation-request-level: <lvl> } } } }
lldp port <ports> vendor-specific dot1q-framing <mode:auto,untagged,tagged>
	port: { <ports>: { lldp: { vendor-specific: { dot1q-framing: <mode> } } } }
exit
interface Ethernet ALL
no lldp tx-tlv port <ports> vendor-specific poe-conservation
	port: { <ports>: { lldp: { tx-tlv: { vendor-specific: { poe-conservation: false } } } } }
no lldp tx-tlv port <ports> vendor-specific call-server
	port: { <ports>: { lldp: { tx-tlv: { vendor-specific: { call-server: false } } } } }
no lldp tx-tlv port <ports> vendor-specific file-server
	port: { <ports>: { lldp: { tx-tlv: { vendor-specific: { file-server: false } } } } }
no lldp tx-tlv port <ports> vendor-specific dot1q-framing
	port: { <ports>: { lldp: { tx-tlv: { vendor-specific: { dot1q-framing: false } } } } }
exit

! *** 802.1AB MED Voice Network Policies ***
interface Ethernet ALL
lldp med-network-policies [port <ports>] voice dscp <dscp> priority <priority> tagging <tag:tagged,untagged> vlan-id <vid>
	port: {
		<ports>: {
			lldp: {
				med: {
					voice: {
						dscp: <dscp>
						priority: <priority>
						tagging: <tag>
						vlan: <vid>
					}
				}
			}
		}
	}
no lldp med-network-policies port <ports> voice
exit

! *** QOS ***
qos if-group name <name> class <class>
	qos: { if-group: { <name>: <class> } }
qos l2-element <id> name <name>
	qos: { l2-element: { <id>: { name: <name> } } }
qos classifier <id> set-id <sid> name <name> element-type <type:l2,ip> element-id <eid>
	qos: { classifier: { <id>: {
		name: <name>
		set-id: <sid>
		element-type: <type>
		element-id: <eid>
	} } }
qos if-assign port <ports> name <name>
	port: {	<ports>: { qos: { if-group: <name> } } }
qos agent queue-set <qset>
	qos: { queue-set: <qset> }
qos agent ubp disable
	qos: { ubp: { enable: true } }
qos agent statistics-tracking <mode:aggregate,individual,disable>
	qos: { statistics-tracking: <mode> }
qos agent dos-attack-prevention [min-tcp-header <mth>] [max-ipv4-icmp <mi4i>] [max-ipv6-icmp <mi6i>]
	qos: { dos-attack-prevention: {
		min-tcp-header: <mth>
		max-ipv4-icmp: <mi4i>
		max-ipv6-icmp: <mi6i>
	} }
qos agent dos-attack-prevention enable
	qos: { dos-attack-prevention: { enable: true } }
qos agent aq-mode <mode:disable,mixed,pure>
	qos: { auto-qos: <mode> }
qos egressmap name <name> ds <dscp> 1p <pbit> dp <dp:high-drop,low-drop> ds-new <newdscp>
qos ingressmap name <name> 1p <pbit> ds <dscp>
qos agent ubp high-security-local
	qos: { ubp: { high-security-local: true } }
qos queue-set-assignment queue-set <qset> 1p <pbit> queue <queue>
	qos: { ingress-map: { p-bit: { <pbit> : <queue> } } }
	qos: { queue-set: { <qset>: { 1p: <pbit>, queue: <queue> } } }
qos ubp classifier name <name> [addr-type <atype>] [ds-field <dscp>] [ethertype <etype>] drop-action <drpa:enable,disable> [block <blk>] [eval-order <evrd>]
	qos: { ubp: { <name>: { classifier: {
		drop: <drpa:enable=true,disable=false>
		addr-type: <atype>
		ds-field: <dscp>
		ethertype: <etype>
		eval-order: <evrd>
	} } } }
qos ubp set name <name> set-priority <priority> track-statistics <stat:aggregate,individual,disable>
	qos: { ubp: { <name>: { set: {
		priority: <priority>
		statistics: <stat:disable=null>
	} } } }
qos traffic-profile classifier name <name> [addr-type <atype>] [src-ip <srcip>] [dst-ip <dstip>] [ds-field <dscp>] [ethertype <etype>] [drop-action <drpa:enable,disable>] [update-dscp <udscp>] [block <blk>] [eval-order <evrd>] [update-dscp-out-action <udscpout>]
	qos: { traffic-profile: { <name>: { classifier: {
		drop: <drpa:enable=true,disable=false>
		addr-type: <atype>
		src-ip: <srcip>
		dst-ip: <dstip>
		ds-field: <dscp>
		ethertype: <etype>
		eval-order: <evrd>
		update-dscp: <udscp>
		update-dscp-out-action: <udscpout>
	} } } }
qos traffic-profile set port <ports> name <name> [meter-mode <mtmode>] [committed-rate <cmrate>] [committed-burst-size <cmbs>] [drop-out-action <drpa:enable,disable>] track-statistics <stat:aggregate,individual,disable>
	qos: { traffic-profile: { <name>: { set: {
		drop: <drpa:enable=true,disable=false>
		statistics: <stat:disable=null>
		policer: {
			meter-mode: <mtmode>
			committed-rate: <cmrate>
			burst-size: <cmbs>
		}
	} } } }

! *** RMON ***

! *** SPBM (Phase 1) ***
spbm
	isis: {spbm: {enable: true } }
router isis
spbm <id>
	isis: {spbm: {instance: <id> } }
spbm <id> b-vid <vids> primary <vid>
	isis: {spbm: {
		bvids: <vids>
		primary-bvid: <vid>
	} }
spbm <id> nick-name <nick>
	isis: {spbm: {nick-name: <nick> } }
spbm <id> ip enable
	isis: {spbm: {ip: true } }
manual-area <area>
	isis: { area: <area> }
interface Ethernet <!ports>
isis
	port: { <ports>: {isis: {} } }
isis spbm <id>
	port: { <ports>: {isis: { spbm: { instance: <id> } } } }
isis spbm <id> l1-metric <metric>
	port: { <ports>: {isis: { spbm: { metric: <metric> } } } }
isis enable
	port: { <ports>: {isis: { enable: true } } }
exit
router isis
system-id <sysid>
	isis: {system-id: <sysid> }
sys-name <sysname>
	isis: {system-name: <sysname> }
exit

! *** EAP Guest VLAN ***
eapol guest-vlan [<ena:enable>] vid <vid>
	eapol: { guest-vlan : { enable: <ena:%>, vlan-id: <vid> } }
interface Ethernet ALL
eapol guest-vlan port <ports> enable
	port: { <ports>: { eapol: { guest-vlan: true } } }
exit

! *** EAP ***



eapol multihost allow-non-eap-enable
	eapol: { multihost: { neap: true } }
eapol multihost radius-non-eap-enable
	eapol: { multihost: { neap-radius: true } }
eapol multihost multivlan enable
	eapol: { multihost: { multivlan: true } }
eapol multihost auto-non-eap-mhsa-enable
	eapol: { multihost: { neap-mhsa: true } }
eapol multihost non-eap-phone-enable
	eapol: { multihost: { non-eap-phone: true } }
eapol multihost use-radius-assigned-vlan
	eapol: { multihost: { radius-assigned-vlan: true } }
eapol multihost non-eap-use-radius-assigned-vlan
	eapol: { multihost: { neap-radius-assigned-vlan: true } }
eapol multihost eap-packet-mode <mode:unicast,multicast>
	eapol: { multihost: { eap-packet-mode: <mode> } }
eapol multihost non-eap-reauthentication-enable
	eapol: { multihost: { neap-reauth: true } }
eapol multihost adac-non-eap-enable
	eapol: { multihost: { adac-neap: true } }
eapol multihost radius-non-eap-delay <delay>
	eapol: { multihost: { radius-neap-delay: <delay> } }
interface Ethernet ALL
eapol multihost port <ports> [<enable:enable>] [eap-mac-max <eapmax>] [non-eap-mac-max <neapmax>] [<neaploc:allow-non-eap-enable>] [<neaprad:radius-non-eap-enable>] [<neapmhsa:auto-non-eap-mhsa-enable>] [<eaprav:use-radius-assigned-vlan>] [<neaprav:non-eap-use-radius-assigned-vlan>] [eap-packet-mode <mode:unicast,multicast>] [mac-max <max>] [<neapphone:non-eap-phone-enable>] [<adacneap:adac-non-eap-enable>] [<mhsanolim:mhsa-no-limit>]
	port: { <ports>: { eapol: { multihost: {
		enable: <enable:%>
		mac-max: <max>
		mhsa: {
			no-limit: <mhsanolim:%>
		}
		eap: {
			mac-max: <eapmax>
			radius-assigned-vlan: <eaprav:%>
			packet-mode: <mode>
		}
		neap: {
			local: <neaploc:%>
			mac-max: <neapmax>
			radius: <neaprad:%>
			radius-assigned-vlan: <neaprav:%>
			auto-mhsa: <neapmhsa:%>
			phone: <neapphone:%>
			adac: <adacneap:%>
		}
	} } } }
no eapol multihost port <ports> [<enable:enable>] [<neaploc:allow-non-eap-enable>] [<neaprad:radius-non-eap-enable>] [<neapmhsa:auto-non-eap-mhsa-enable>] [<eaprav:use-radius-assigned-vlan>] [<neaprav:non-eap-use-radius-assigned-vlan>] [<neapphone:non-eap-phone-enable>] [<adacneap:adac-non-eap-enable>] [<mhsanolim:mhsa-no-limit>]
	port: { <ports>: { eapol: { multihost: {
		enable: <enable:!%>
		mhsa: {
			no-limit: <mhsanolim:!%>
		}
		eap: {
			radius-assigned-vlan: <eaprav:!%>
		}
		neap: {
			local: <neaploc:!%>
			radius: <neaprad:!%>
			radius-assigned-vlan: <neaprav:!%>
			auto-mhsa: <neapmhsa:!%>
			phone: <neapphone:!%>
			adac: <adacneap:!%>
		}
	} } } }
exit
eapol allow-port-mirroring
	eapol: { mirroring: true }
eapol user-based-policies enable
	eapol: { ubp: { eap: { enable: true } } }
eapol user-based-policies filter-on-mac enable
	eapol: { ubp: { eap: { filter-on-mac: true } } }
eapol user-based-policies dynamic-ubp enable
	eapol: { ubp: { eap: { dynamic-ubp: true } } }
eapol multihost non-eap-user-based-policies enable
	eapol: { ubp: { neap: { enable: true } } }
eapol multihost non-eap-user-based-policies filter-on-mac enable
	eapol: { ubp: { neap: { filter-on-mac: true } } }
eapol multihost non-eap-user-based-policies dynamic-ubp enable
	eapol: { ubp: { neap: { dynamic-ubp: true } } }
no eapol multihost non-eap-pwd-fmt <item>
	eapol: { multihost: { neap-password-format: { <item>: false } } }
eapol multihost non-eap-pwd-fmt <item>
	eapol: { multihost: { neap-password-format: { <item>: true } } }
interface Ethernet ALL

eapol port 1/1  re-authentication-period 3600 quiet-interval 60 

eapol port <ports> [status <status:auto,authorized,unauthorized>] [traffic-control <tc:in-out,in>] [re-authentication <reauth:enable,disable>] [re-authentication-period <period>] [quiet-interval <quiet>] [supplicant-timeout <suptim>] [server-timeout <srvtim>] [max-request <maxreq>]
	port: { <ports>: { eapol: {
		enable: <status:auto=true,authorized=false,unauthorized=false>
		traffic-control: <tc>
		reauth: <reauth:enable=true,disable=false>
		reauth-period: <period>
		quiet-interval: <quiet>
		supplicant-timeout: <suptim>
		server-timeout: <srvtim>
		max-request: <maxreq>
	} } }
eapol port <ports> radius-dynamic-server enable
	port: { <ports>: { eapol: {
		radius-dynamic-server: true
	} } }
exit

! *** EAP Fail Open VLAN ***
eapol multihost fail-open-vlan vid <vid>
	eapol: { multihost: { fail-open-vlan: { vlan: <vid> } } }
eapol multihost fail-open-vlan enable
	eapol: { multihost: { fail-open-vlan: { enable: true } } }
eapol multihost fail-open-vlan continuity-mode enable
	eapol: { multihost: { fail-open-vlan: { continuity-mode: true } } }

interface Ethernet ALL
eapol multihost fail-open-vlan port <ports> [<enable:enable>] vid <vidmode:port-pvid,global>
	port: { <ports>: { eapol: { multihost: {
		fail-open-vlan: {
			enable: <enable:%>
			vid-mode: <vidmode>
	} } } } }
eapol multihost fail-open-vlan port <ports> [<enable:enable>] vid <vid:1-4094>
	port: { <ports>: { eapol: { multihost: {
		fail-open-vlan: {
			enable: <enable:%>
			vid-mode: vlan-id
			vlan: <vid>
	} } } } }
eapol multihost fail-open-vlan [port <ports>] [<enable:enable>] ubp <profile>
	port: { <ports>: { eapol: { multihost: { fail-open-vlan: { ubp : {
			enable: <enable:%>
			classifier: <profile>
	} } } } } }
exit

! *** EAP Voip VLAN ***
eapol multihost voip-vlan <n> [<enable:enable>] vid <vid:1-4094>
	eapol: { multihost: { voip-vlan: { <n>: { enable: <enable:%>, vlan-id: <vid> } } } }
eapol enable
	eapol: { enable: true }

! *** Interface ***
interface Ethernet ALL
shutdown port <ports>
	port: { <ports>: { shutdown: true } }
snmp trap link-status port <ports> disable
	port: { <ports>: { snmp: { link-trap: false } } }
speed port <ports> <speed:10,100,1000,10000>
	port: { <ports>: {
		speed: <speed>
		auto-negotiation: false
	} }
speed port <ports> auto
	port: { <ports>: {
		auto-negotiation: true
	} }
flowcontrol port <ports> <mode:disable,asymmetric,auto>
	port: { <ports>: { flow-control: <mode> } }
duplex port <ports> <duplex:full,half>
	port: { <ports>: {
		duplex: <duplex>
		auto-negotiation: false
	} }
duplex port <ports> auto
	port: { <ports>: {
		auto-negotiation: true
	} }
name port <ports> <name>
	port: { <ports>: { name: <name> } }
ddi-logging enable
	port: { <ports>: { ddi-logging: true } }
exit
interface mgmt <!unit>
speed <speed:10,100,1000>
	mgmt: { oob: { unit: { <unit>: { speed: <speed>, auto-negotiation: false } } } }
speed auto
	mgmt: { oob: { unit: { <unit>: { auto-negotiation: true } } } }
duplex <duplex:full,half>
	mgmt: { oob: { unit: { <unit>: { duplex: <duplex>, auto-negotiation: false } } } }
duplex auto
	mgmt: { oob: { unit: { <unit>: { auto-negotiation: true } } } }
exit

! *** Rate-Limit ***
rate-limit port <ports> broadcast <rate>
	port: { <ports>: { rate-limit: { broadcast: <rate> } } }
rate-limit port <ports> multicast <rate>
	port: { <ports>: { rate-limit: { multicast: <rate> } } }
rate-limit port <ports> both <rate>
	port: { <ports>: { rate-limit: { broadcast: <rate>, multicast: <rate> } } }

! *** MLT (Phase 1) ***
mlt <mltid> name <name> [<enable>] member <ports>
	mlt: {
		<mltid>: {
			name: <name>
			enable: <enable:%>
			member: <ports>
		}
	}
	port: {
		<ports>: {
			mlt: <mltid>
		}
	}
mlt <mltid> learning enable
	mlt: { <mltid>: { spanning-tree: { enable: true } } }
mlt <mltid> bpdu <mode:single-port,all-ports>
	mlt: { <mltid>: { spanning-tree: { bpdu-mode: <mode> } } }
mlt <mltid> loadbalance <mode:advance,basic>
	mlt: { <mltid>: { loadbalance: <mode> } }

! *** MAC-Based Security ***
mac-security security-list <n> <ports>
	mac-security: { security-list: { <n>: { ports: <ports> } } }
	port: { <ports>: { mac-security: { security-list: <n> } } }
interface Ethernet ALL
mac-security port <ports> enable
	port: { <ports>: { mac-security: { enable: true } } }
mac-security port <ports> lock-out
	port: { <ports>: { mac-security: { lock-out: true } } }
mac-security auto-learning <ports> max-addrs <macs>
	port: { <ports>: { mac-security: { max-addrs: <macs> } } }
mac-security auto-learning port <ports> enable
	port: { <ports>: { mac-security: { auto-learning: true } } }
exit
mac-security enable
	mac-security: { enable: true }
mac-security snmp-lock enable
	mac-security: { snmp-lock: true }
mac-security intrusion-timer <tmr>
	mac-security: { intrusion-timer: <tmr> }
mac-security intrusion-detect enable intrusion-timer <timer>
	mac-security: {
		intrusion-detect: true 
		intrusion-timer: <timer>
	}
mac-security filtering enable
	mac-security: { filtering: true }
mac-security auto-learning aging-time <time>
	mac-security: { auto-learning: { aging-time: <time> } }
mac-security auto-learning sticky
	mac-security: { auto-learning: { sticky: true } }
mac-security learning-ports <ports>
	mac-security: { learning-ports: <ports> }
	port: { <ports>: { mac-security: { learning: true } } }
mac-security mac-address-table address <mac> security-list <seclist>
	mac-security: { mac-table: { address: { <mac>: { security-list: <seclist> } } } }
mac-security mac-address-table address <mac> port <port>
	mac-security: { mac-table: { address: { <mac>: { port: <port> } } } }
mac-security mac-address-table address <mac> mlt-id <mltid>
	mac-security: { mac-table: { address: { <mac>: { mlt: <mltid> } } } }
mac-security mac-address-table sticky-address <mac> port <port>
	mac-security: { mac-table: { sticky-address: { <mac>: { port: <port> } } } }
mac-security mac-address-table sticky-address <mac> mlt-id <mltid>
	mac-security: { mac-table: { sticky-address: { <mac>: { mlt: <mltid> } } } }

! *** LACP (Phase 2) ***
lacp system-priority <priority>
	lacp: { priority: <priority> }
lacp port-mode <mode:default,advance>
	lacp: { port-mode: <mode> }
interface Ethernet ALL
lacp key port <ports> <key>
	port: { <ports>: { lacp: { key: <key> } } }
lacp mode port <ports> <mode:active,passive>
	port: { <ports>: { lacp: {
		enable: true
		passive: <mode:passive=true,active=false>
	}}}
lacp priority port <ports> <priority>
	port: { <ports>: { lacp: { priority: <priority> } } }
lacp timeout-time port <ports> <tt:short,long>
	port: { <ports>: { lacp: { timeout-time: <tt> } } }
lacp aggregation port <ports> enable
	port: { <ports>: { lacp: { aggregation: true } } }
exit

! *** ADAC ***
interface Ethernet ALL
adac port <ports> enable
	port: { <ports>: { adac: true } }
	adac: { ports: <ports> }
exit
adac voice-vlan <vid>
	adac: { voice-vlan: <vid> }
adac call-server-port <port>
	adac: { call-server-port: <port> }
adac uplink-port <port>
	adac: { uplink-port: <port> }
adac op-mode <mode:tagged-frames,untagged-frames-basic,untagged-frames-advanced>
	adac: { op-mode: <mode> }
adac enable
	adac: { enable: true }

! *** MSTP (Phase 2) ***
spanning-tree mstp remove-vlan <vid>
	spanning-tree: { mstp: {remove-vlans: [<vid>] } }
interface Ethernet ALL
spanning-tree mstp port <ports> edge-port <edge:true,false>
	spanning-tree: { mode: mstp }
	port: { <ports>: { mstp: { edge-port: <edge> } } }
spanning-tree mstp port <ports> learning <learning:enable,disable>
	spanning-tree: { mode: mstp }
	port: { <ports>: { spanning-tree: { learning: <learning:enable=true,disable=false> } } }
spanning-tree mstp port <ports> priority <priority>
	port: { <ports>: { spanning-tree: { priority: <priority> } } }
spanning-tree mstp port <ports> hello-time <secs>
	port: { <ports>: { spanning-tree: { hello-time: <secs> } } }
spanning-tree mstp port <ports> p2p <mode:auto,force-false,force-true>
	port: { <ports>: { spanning-tree: { mstp: { p2p: <mode> } } } }
spanning-tree bpdu-filtering port <ports> [<enable:enable>] [timeout <secs>]
	port: { <ports>: { bpdu-guard: {
		enable: <enable:%>
		timeout: <secs>
	} } }
exit

! *** Port Mirroring ***

! *** VLAN Phase 2***
vlan mgmt <vid>
	mgmt: { vlan: { vlan-id: <vid> } }
	vlan: { <vid>: { mgmt: true } }

! *** MLT (Phase 2) ***
mlt spanning-tree <mltid> [cist] learning <learning:enable,disable>
	mlt: { <mltid>: { spanning-tree: { enable: <learning:enable=true,disable=false> } } }

! *** PoE ***
interface Ethernet ALL
poe-shutdown port <ports>
	port: { <ports>: { poe: { shutdown: true } } }
poe poe-priority port <ports> <prio:low,high,critical>
	port: { <ports>: { poe: { priority: <priority> } } }
poe poe-limit port <ports> <watts>
	port: { <ports>: { poe: { limit: <watts> } } }
poe poe-power-up-mode port <ports> <mode:802.3at,802.3af,pre-802.3at,high-inrush>
	port: { <ports>: { poe: { power-up-mode: <mode> } } }

! *** RTC ***
clock source <src>
	system: { clock: { source: <src> } }
clock summer-time recurring <weeknumb1> <weekday1> <month1> <time1> <weeknumb2> <weekday2> <month2> <time2> <minutes>
	system: { clock: { summer-time: {
		start: {
			week-number: <weeknumb1>
			week-day: <weekday1>
			month: <month1>
			time: <time1>
		}
		end: {
			week-number: <weeknumb2>
			week-day: <weekday2>
			month: <month2>
			time: <time2>
		}
		minutes: <minutes>
	} } }
clock time-zone <tz> <hdiff> [<mdiff>]
	system: { clock: { time-zone: { time-zone: <tz>, hours-from-UTC: <hdiff>, minutes-from-UTC: <mdiff> } } }

! *** Extreme Networks Energy Saver ***
energy-saver enable
	energy-saver: { enable: true }
energy-saver efficiency-mode
	energy-saver: { efficiency-mode: true }
energy-saver schedule <day> <time> <action:activate,deactivate>
	energy-saver: { schedule: [{ day: <day>, time: <time>, action: <action> }] }
interface Ethernet ALL
energy-saver port <ports> enable
	energy-saver: { ports: [<ports>] }
	port: { <ports>: { energy-saver: true } }
exit
energy-saver poe-power-saving
	energy-saver: { poe-power-saving: true }

! *** AUR ***
no stack auto-unit-replacement enable
	stack: { auto-unit-replacement: { enable: false } }
no stack auto-unit-replacement config save enable
	stack: { auto-unit-replacement: { auto-save: false } }

! *** AAUR ***
no stack auto-unit-replacement-image enable
	stack: { auto-unit-replacement: { image-update: false } }

! *** L3 ***
interface vlan <!vid>
ip address <ip> <mask> <macoffset:0-999>
	vlan: { <vid>: { ip: <ip>, mask: <mask> } }
	ip: { interface: { <ip>: { mask: <mask>, vlan: <vid> } } }
ip spb-multicast enable
	vlan: { <vid>: { spb-multicast: true } }
exit
interface loopback <!clip>
ip address <ip> <mask>
	ip: { circuitless: {<clip>: { ip: <ip>, mask: <mask> } } }
	ip: { interface: { <ip>: { mask: <mask>, loopback: <clip> } } }
exit

! --- ECMP ---
ip route <route> <mask> <ip> <weight>
	ip: { route: [{
		route: <route>
		mask: <mask>
		next-hop: <ip>
		weight: <weight>
		}]
	}
ip routing
	ip: { routing: true }

! *** Brouter Port ***

! *** CORE (Phase 2) ***
no mac-address-table learning <ports>
	port: { <ports>: { no-mac-learning: true } }

! *** IPV6 ***
ipv6 enable
	ipv6: {enable: true}

! *** MLD ***

! *** FHS ***

! --- FHS Global settings ---

! --- IPV6 access list settings ---

! --- IPv6 mac access list settings ---

! --- IPV6 dhcp guard  settings ---

! --- IPV6 RA Guard settings ---

! --- IPV6 Policy Port Map settings ---

! --- IPV6 FHS ND SBT Table settings ---

! --- IPV6 Source Guard Interface settings ---

! *** RIPNG ***

! *** VRRPV3 ***

! *** IPsec ***

! *** IKE ***

! *** VLACP ***
vlacp enable
	vlacp: { enable: true }
vlacp macaddress <mac>
	vlacp: { macaddress: <mac> }
vlacp hold_time <time>
	vlacp: { hold-time: <time> }
interface Ethernet ALL
vlacp port <ports> timeout <type:long,short>
	port: { <ports>: { vlacp: { timeout: <type> } } }
vlacp port <ports> timeout-scale <timescale>
	port: { <ports>: { vlacp: { timeout-scale: <timescale> } } }
vlacp port <ports> ethertype <etype>
	port: { <ports>: { vlacp: { ethertype: <etype> } } }
vlacp port <ports> fast-periodic-time <msec>
	port: { <ports>: { vlacp: { fast-periodic-time: <msec> } } }
vlacp port <ports> slow-periodic-time <msec>
	port: { <ports>: { vlacp: { slow-periodic-time: <msec> } } }
vlacp port <ports> enable
	port: { <ports>: { vlacp: { enable: true } } }
exit

! *** DHCP Relay ***
ip dhcp-relay
	dhcp-relay: {enable: true}
no ip dhcp-relay
	dhcp-relay: {enable: false}
ip dhcp-relay option82
	dhcp-relay: {option82: true}
ip dhcp-relay fwd-path <ip> <srv>
	ip: { interface: { <ip>: { dhcp-relay: { server: <srv> } } } }
ip dhcp-relay fwd-path <ip> <srv> mode <mode>
	ip: { interface: { <ip>: { dhcp-relay: { server: <srv>, mode: <mode> } } } }
interface vlan <!vid>
ip dhcp-relay mode <mode>
	vlan: { <vid>: { dhcp-relay: { enable: true, mode: <mode> } } }
exit
interface Ethernet <!ports>
ip dhcp-relay [port <ports>] option82-subscriber-id <name>
	port: { <ports>: { dhcp-relay: { option82-subscriber-id: <name> } } }
exit

! *** L3 Source Interface ***

! *** L3 Protocols ***
arp timeout <min>
	ip: { arp: { aging: <min> } }

! --- IP Directed Broadcast ---
#ip directed-broadcast enable
#	ip: { directed-broadcast: true }
interface vlan <!vid>
ip directed-broadcast enable			# Same both globally and per vlan..
	ip: { directed-broadcast: true }
	vlan: { <vid>: { directed-broadcast: true } }
exit

! --- Proxy ARP ---

! --- UDP Broadcast Forwarding ---
	
! --- VRRP ---
router vrrp enable
	vrrp: { enable: true }
router vrrp
ping-virtual-address enable
	vrrp: { ping-virtual-address: true }
exit

! --- Route Policies ---

! --- OSPF ---
router ospf enable
	ospf: { enable: true }
router ospf
router-id <ip>
	ospf: { router-id: <ip> }
as-boundary-router enable
	ospf: { asbr: true }
default-cost ethernet <cost>
	ospf: { default-cost: { ethernet: <cost> } }
default-cost fast-ethernet <cost>
	ospf: { default-cost: { fast-ethernet: <cost> } }
default-cost gig-ethernet <cost>
	ospf: { default-cost: { gig-ethernet: <cost> } }
default-cost ten-gig-ethernet <cost>
	ospf: { default-cost: { ten-gig-ethernet: <cost> } }
exit

! --- RIP ---
router rip
router rip enable
	rip: { enable: true }
exit

! *** SPBM (Phase 2) ***
router isis
ip-source-address <ip>
	isis: { ip-source-address: <ip> }
exit
router isis enable
	isis: { enable: true }

! *** IP Forwarding Next-Hop ***

! *** DHCP SNOOPING ***
ip dhcp-snooping
	dhcp-snooping: { enable: true }
ip dhcp-snooping option82
	dhcp-snooping: { option82: true }
ip dhcp-snooping vlan <vids>
	vlan: { <vids>: { dhcp-snooping: { enable: true } } }
ip dhcp-snooping vlan <vids> option82
	vlan: { <vids>: { dhcp-snooping: { option82: true } } }
interface Ethernet ALL
ip dhcp-snooping port <ports> <mode:trusted,untrusted>
	port: { <ports>: { dhcp-snooping: { mode: <mode> } } }
exit
interface Ethernet <!ports>
ip dhcp-snooping [port <ports>] option82-subscriber-id <name>
	port: { <ports>: { dhcp-snooping: { option82-subscriber-id: <name> } } }
exit

! *** ARP INSPECTION ***
ip arp-inspection vlan <vids>
	vlan: { <vids>: { arp-inspection: { enable: true } } }
interface Ethernet ALL
ip arp-inspection port <ports> <mode:trusted,untrusted>
	port: { <ports>: { arp-inspection: { mode: <mode> } } }
exit

! *** IP SOURCE GUARD ***
interface Ethernet ALL
ip verify source [interface <ports>]
	port: { <ports>: { ip-source-guard: true } }
ip verify source [interface ethernet <ports>]
	port: { <ports>: { ip-source-guard: true } }
exit

! *** IGMP ***
interface vlan <!vid>
ip igmp router-alert
	vlan: { <vid>: { igmp: { router-alert: true } } }
ip igmp
	vlan: { <vid>: { igmp: { enable: true } } }
ip igmp snooping
	vlan: { <vid>: { igmp: { snooping: true } } }
ip igmp proxy
	vlan: { <vid>: { igmp: { proxy: true } } }
ip igmp send-query
	vlan: { <vid>: { igmp: { send-query: true } } }
ip igmp [version <vers>] [last-member-query-interval <lmqi>] [query-interval <qint>] [query-max-response <qmr>] [robust-value <robv>]
	vlan: { <vid>: { igmp: {
		version: <vers>
		last-member-query-interval: <lmqi>
		query-interval: <qint>
		query-max-response: <qmr>
		robust-value: <robv>
	} } }
ip igmp mrouter <ports>
	vlan: { <vid>: { igmp: { mrouter-ports: <ports> } } }
exit

! *** MVR ***
mvr enable
	mvr: { enable: true }

! *** STACK MONITOR ***
stack-monitor enable
	stack: { stack-monitor: { enable: true } }
stack-monitor stack-size <size>
	stack: { stack-monitor: { stack-size: <size> } }
stack-monitor trap-interval <int>
	stack: { stack-monitor: { trap-interval: <int> } }

! *** SLPP ***
slpp [<enable:enable>] [vid <vids>] 
	slpp: { enable: true, vlans: [<vids>] }
	vlan: { <vids>: { slpp: true } }
slpp [ethertype <etype>] [tx-interval <int>] [timeout <tim>]
	slpp: {
		ethertype: <etype>
		tx-interval: <int>
		timeout: <tim>
	}
interface Ethernet ALL
slpp port <ports> [<enable:enable>] [packet-rx-threshold <thr>]
	port: { <ports>: { slpp: {
		enable: <enable:%>
		rx-threshold: <thr>
	} } }
exit

! *** SLPP-guard ***
slpp-guard ethertype <etype>
	slpp-guard: { ethertype: <etype> }
interface Ethernet ALL
slpp-guard port <ports> [<enable:enable>] [timeout <time>]
	port: { <ports>: { slpp-guard: {
		enable: <enable:%>
		timeout: <time>
	} } }
exit

! *** PIM ***

! *** CFM ***
cfm spbm level <lev>
	cfm: { spbm: { level: <lev> } }
cfm spbm mepid <id>
	cfm: { spbm: { mepid: <id> } }
cfm spbm enable
	cfm: { spbm: { enable: true } }

! *** SLAMON ***
application
slamon oper-mode enable
	slamon: { enable: true }
slamon cli enable
	slamon: { cli: true }
slamon server-bypass enable
	slamon: { server-bypass: true }
exit

! *** STORM CONTROL ***
storm-control <type:unicast,broadcast,multicast> enable
	storm-control: { <type>: { enable: true } }
storm-control <type:unicast,broadcast,multicast> [low-watermark <lwm>] [high-watermark <hwm>] [poll-interval <pint>] [action <act:none,drop,shutdown>] [trap-interval <tint>]
	storm-control: { <type>: {
		low-watermark: <lwm>
		high-watermark: <hwm>
		poll-interval: <pint>
		action: <act>
		trap-interval: <tint>
	} }
interface Ethernet ALL
storm-control <type:unicast,broadcast,multicast> port <ports> enable
	port: { <ports>: { storm-control: { <type>: true } } }
	storm-control: { <type>: { ports: [<ports>] } }
exit

! *** LINK STATE TRACKING ***

! *** SFLOW ***
sflow enable
	sflow: { enable: true }
sflow collector <id> address <ip> [owner <owner>] [port <udport>]
	sflow: { collector: { <id>: { ip: <ip>, owner: <owner>, udp-port: <udpport> } } }
sflow collector <id> max-datagram-size <size>
	sflow: { collector: { <id>: { max-datagram-size: <size> } } }
interface Ethernet ALL
sflow port <ports> sampling-rate ingress <ing>
	port: { <ports>: { sflow: { sampling-rate: { ingress: <ing> } } } }
sflow port <ports> sampling-rate egress <egr>
	port: { <ports>: { sflow: { sampling-rate: { egress: <egr> } } } }
sflow port <ports> counter-interval <int>
	port: { <ports>: { sflow: { counter-interval: <int> } } }
sflow port <ports> collector <id>
	port: { <ports>: { sflow: { collector: <id> } } }
exit

! *** Application Telemetry ***
app-telemetry collector address <ip>
	app-telemetry: { collector: <ip> }
app-telemetry [<enable:enable>] ports <ports>
	app-telemetry: { enable: <enable:%>, ports: <ports> }
	port: { <ports>: { app-telemetry: true } }

! *** Fabric Attach ***
fa zero-touch disable-mgmt-vlan-distribution
	fabric-attach: { forward-mgmt-vlan: false }
fa standalone-proxy
	fabric-attach: { standalone-proxy: { enable: true } }
fa uplink port <port>
	fabric-attach: { standalone-proxy: { uplink: { port: <port> } } }
fa uplink trunk <mltid>
	fabric-attach: { standalone-proxy: { uplink: { mlt: <mltid> } } }
fa timeout <secs>
	fabric-attach: { timeout: <secs> }
fa extended-logging
	fabric-attach: { extended-logging: true }
fa port-enable <ports>
	port: { <ports>: { fabric-attach: { enable: true } } }
no fa port-enable <ports>
	port: { <ports>: { fabric-attach: { enable: false } } }
fa zero-touch-option auto-port-mode-fa-client client-type <clid>
	fabric-attach: { zero-touch-option: { auto-neap-mode: { enable: true, client-type: [<clid>] } } }
fa zero-touch-option auto-trusted-mode-fa-client client-type <clid>
	fabric-attach: { zero-touch-option: { auto-trusted-mode: { enable: true, client-type: [<clid>] } } }
fa zero-touch-option auto-pvid-mode-fa-client client-type <clid>
	fabric-attach: { zero-touch-option: { auto-pvid-mode: { enable: true, client-type: [<clid>] } } }
fa zero-touch-option auto-mgmt-vlan-fa-client client-type <clid>
	fabric-attach: { zero-touch-option: { auto-mgmt-vlan: { enable: true, client-type: [<clid>] } } }
fa zero-touch-option auto-client-attach client-type <clid>
	fabric-attach: { zero-touch-option: { auto-client-attach: { enable: true, client-type: [<clid>] } } }
fa zero-touch-client standard <type> vlan <vid> i-sid <isid>
	fabric-attach: { zero-touch-client: { <type>: { vlan: <vid>, i-sid: <isid> } } }
no fa port-enable <ports>
	port: { <ports>: { fabric-attach: { enable: false } } }
fa message-authentication <ports> key-mode <km:standard,strict>
	port: { <ports>: { fabric-attach: { message-authentication: { key-mode: <km> } } } }
no fa message-authentication <ports>
	port: { <ports>: { fabric-attach: { message-authentication: { enable: false } } } }
fa timeout <time>
	fabric-attach: { timeout: <time> }
i-sid <isid> vlan <vid>
	vlan: {<vid>: { i-sid: <isid> } }
	i-sid: {<isid>: { vlan: <vid> } }

! *** MACsec ***
macsec connectivity-association <cnas> connectivity-association-key <key>
	macsec: { connectivity-association: { <cnas>: { key: <key> } } }
interface Ethernet <!ports>
macsec connectivity-association <cnas>
	port: { <ports>: { macsec: { connectivity-association: <cnas> } } }
macsec encryption enable
	port: { <ports>: { macsec: { encryption: true } } }
macsec enable
	port: { <ports>: { macsec: { enable: true } } }
exit

! *** ZTP+ ***
no auto-provision enable
	ztp: {enable: false }


=cut

################################################################################
#                    PERL Post-Processing of Data Structure                    #
################################################################################
#
# Perl code can begin here.
# This code can be used to coerce the extracted data into the desired schema.
# Must be a subroutine named "run"
# This code is called after the all the data has been extracted from the original config file
# and it allows us to alter the structure of the data to comply with the data schema we are aiming for
# Note that keys containing '-' character must be quoted...

use Data::Dumper;
use Storable 'dclone';

sub run { # Function must be named "run" and will be executed as Encoder::run
	my $data = shift; # The extracted data structure is passed as a hash reference

	# We want the switch mgmt IP to be reflected under the vlan IP config..
	#	ip address switch <ip>
	#		mgmt: { vlan: { ip: <ip> } }
	#		ip: { interface: { <ip>: { mgmt-vlan: true } } }
	#	ip [address] netmask <mask>
	#		mgmt: { vlan: { mask: <mask> } }
	#		ip: { interface: { $mgmt{vlan}{ip}: { mask: <mask> } } }
	# I.e. here also:
	#		vlan: { $mgmt{vlan}{vlan-id}: { ip: <ip>, mask: <mask> } }
	# but the mgmt-vlan is only known later in the config, so we adjust it here
	# and also the mgmt VLAN to be reflected under the ip interface:
	#		ip: { interface: { <ip>: { vlan: $mgmt{vlan}{vlan-id} } } }
	#
	if (exists $data->{mgmt}->{vlan}->{ip}) {
		my $mgmtIp = $data->{mgmt}->{vlan}->{ip};
		my $mgmtVlan = $data->{mgmt}->{vlan}->{'vlan-id'};
		$data->{vlan}->{$mgmtVlan}->{ip} = $data->{mgmt}->{vlan}->{ip};
		$data->{vlan}->{$mgmtVlan}->{mask} = $data->{mgmt}->{vlan}->{mask};
		$data->{ip}->{interface}->{$mgmtIp}->{vlan} = $mgmtVlan;
	}


	# Make sure that this encoding:
	#	ip dhcp-relay fwd-path <ip> <srv> [mode <mode>]
	#		ip: { interface: { <ip>: { dhcp-relay: { server: <srv>, mode: <mode> } } } }
	# also gets encoded as (where the IP belongs to a VLAN):
	#		vlan: { $ip{interface}{<ip>}{vlan}: { dhcp-relay: { server: <srv>, mode: <mode> } } }
	#
	# As well as:
	#	ip dhcp-relay mode dhcp
	#		vlan: { <vid>: { dhcp-relay: { enable: true } } }
	# into:
	#		ip: { interface: { $vlan{<vid>}{ip}: { dhcp-relay: { enable: true } } } }
	#
	if (exists $data->{ip}->{interface}) {
		for my $ip (keys %{$data->{ip}->{interface}}) {
			my $ipref = $data->{ip}->{interface}->{$ip};
			if (exists $ipref->{vlan} && exists $ipref->{'dhcp-relay'}) {
				$data->{vlan}->{ $ipref->{vlan} }->{'dhcp-relay'} = \%{
					$main::HashMerge->merge(
						$ipref->{'dhcp-relay'},
						$data->{vlan}->{ $ipref->{vlan} }->{'dhcp-relay'}
					)
				};
				$ipref->{'dhcp-relay'} = dclone $data->{vlan}->{ $ipref->{vlan} }->{'dhcp-relay'};
			}
		}
	}

	# When we encode VLAN port membership we capture all the ports: 
	#	vlan members [add] <vids> <ports>
	#		vlan: { <vids>: { ports-all: <ports> } }
	#
	# but we need the data structure to store which ports are added as tagged and which as untagged.
	# This is in case we need to makecfg to EXOS or Switchd UNI VOSS
	# So we parse the ports tagging mode and pvid (in case of untagPvidOnly) and we create these 2 new keys:
	#
	#		vlan: { <vids>: { ports-untagged: <ports>, ports-tagged: <ports> } }
	#
	for my $vlan (keys %{$data->{vlan}}) {
		$vlanRef = $data->{vlan}->{$vlan};
		next unless exists $vlanRef->{'ports-all'};
		@vlanPortList = split(',', main::generatePortList($vlanRef->{'ports-all'}));
		my (@untagPorts, @taggedPorts);
		for my $port (@vlanPortList) {
			my $portRef = $data->{port}->{$port};
			unless (exists $portRef->{tagging}) { # Key not set = port is in default untagAll
				push(@untagPorts, $port);
				next;
			}
			if ($portRef->{tagging} eq 'tagAll') {
				push(@taggedPorts, $port);
			}
			elsif ($portRef->{tagging} eq 'unTagPvidOnly' && $portRef->{pvid} == $vlan) {
				push(@untagPorts, $port);
			}
			else { # unTagPvidOnly and pvid != $vlan
				push(@taggedPorts, $port);
			}
		}
		$vlanRef->{'ports-untagged'} = main::generateRange(join(',', @untagPorts), 1) if @untagPorts;
		$vlanRef->{'ports-tagged'} = main::generateRange(join(',', @taggedPorts), 1) if @taggedPorts;
	}

}

1;

__END__
